{% extends 'partials/base.html' %} 
{% load static %} 
{% block title %}Ground Floor{% endblock %} 
{% block content %}
<link rel="stylesheet" href="{% static '/select/css/multi-select-tag.css' %}" />
<script src="{% static '/select/js/multi-select-tag.js' %}"></script>

<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-2 pb-1 mb-2 border-bottom">
  <h1 class="h2" style="text-transform: capitalize">{{ floor.name }} floor</h1>
</div>


<!-- csrf token -->
{% csrf_token %}

<div class="row form-group mb-2">
  <div class="col">
    <label for="items_name">Select Items</label>
    <div class="d-flex flex-row gap-2" style=" position: relative; z-index: 50;">
      <select name="items[]" id="items_name" multiple required>
        {% for item in items %}
        <option value="{{ item.id }}">
          {{ item.name }} (₹{{ item.price }})
        </option>
        {% empty %}
        <option disabled>No items available</option>
        {% endfor %}
      </select>
      <button id="findRoute" class="btn btn-primary ps-3 pe-3">Find</button>

    </div>
  </div>
</div>
<div id="grid-container" class="grid-container"></div>


<div class="legend">
    <h2>Legend</h2>
    <div class="legend-item">
        <div class="legend-color shelf"></div>
        <span>Shelf</span>
    </div>
    <div class="legend-item">
        <div class="legend-color wall"></div>
        <span>Wall</span>
    </div>
    <div class="legend-item">
        <div class="legend-color checkout"></div>
        <span>Checkout Area</span>
    </div>
    <div class="legend-item">
        <div class="legend-color cart"></div>
        <span>Cart</span>
    </div>
    <div class="legend-item">
        <div class="legend-color entrance"></div>
        <span>Entrance</span>
    </div>
    <div class="legend-item">
        <div class="legend-color exit"></div>
        <span>Exit</span>
    </div>
</div> 



<!-- items from real time data -->



<style>
  .grid-container {
    display: grid;
    grid-template-columns: repeat({{floor.width}}, 1fr);
    margin-top: 20px;
    padding: 10px;
    border: 0;
  }

  .grid-item {
    width: 100%;
    aspect-ratio: 1;
    background-color: #f8f9fa;
    border: 0.5px solid #545454;
  }

  .grid-item.shelf {
    background-color: #ffeb3b;
  }
  .grid-item.wall {
    background-color: #6c757d;
  }
  .grid-item.checkout {
    background-color: #198754;
  }
  .grid-item.cart {
    background-color: #0dcaf0;
  }
  .grid-item.entrance {
    background-color: #ffc107;
  }
  .grid-item.exit {
    background-color: #dc3545;
  }
  .item-counter {
    text-align: center;
    padding: 2px;
    font-size: 12px;
    font-weight: bold;
  }

  /* path */
  .grid-container {
    position: relative;
  }

  .grid-item.route {
    background-color: #28a745 !important;
    animation: pulse 1.5s infinite;
    position: relative;
    z-index: 5;
  }

  .route-svg {
    pointer-events: none;
  }

  @keyframes pulse {
    0% {
      opacity: 0.7;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.05);
    }
    100% {
      opacity: 0.7;
      transform: scale(1);
    }
  }

  /* legend */
  .legend {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #ddd;
    display: inline-block;
  }

  .legend h2 {
    font-size: 1.2em;
    margin-bottom: 10px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
  }

  .legend-color {
    width: 20px;
    height: 20px;
    margin-right: 10px;
  }

  .legend-color.shelf {
    background-color: #ffeb3b;
  }
  .legend-color.wall {
    background-color: #6c757d;
  }
  .legend-color.checkout {
    background-color: #198754;
  }
  .legend-color.cart {
    background-color: #0dcaf0;
  }
  .legend-color.entrance {
    background-color: #ffc107;
  }
  .legend-color.exit {
    background-color: #dc3545;
  }

  /* Add to your stylesheet */
.shelf-item-marker {
    position: absolute;
    background: #e74c3c;
    color: white;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 12px;
    z-index: 50;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transform: translate(-50%, -50%);
}

.shelf-item-marker.priority-1 { background: #e74c3c; }
.shelf-item-marker.priority-2 { background: #f39c12; }
.shelf-item-marker.priority-3 { background: #2ecc71; }
.optimal-path-info {
            position: sticky;
            top: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 14px;
            z-index: 0;
        }
        
        .comparison-results {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric-improvement {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .metric-degradation {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .metric-neutral {
            color: #f39c12;
            font-weight: bold;
        }
        
        .comparison-header {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #3498db;
        } 
</style>

<script>
      const shelves = {{ shelves|safe }};
      const width = {{ floor.width }};
      const length = {{ floor.length }};

      const gridContainer = document.getElementById('grid-container');

      for (let i = 0; i < length * width; i++) {
          const gridItem = document.createElement('div');
          gridItem.classList.add('grid-item');
          gridContainer.appendChild(gridItem);
      }

      shelves.forEach(shelf => {
          const gridItem = gridContainer.children[shelf.cell_index];
          gridItem.classList.add(shelf.mode);

          if (shelf.mode === 'shelf') {
              if (shelf.item_ids && shelf.item_ids.length > 0) {
                  gridItem.innerHTML = `<div class="item-counter">${shelf.item_ids.length} items</div>`;
                  gridItem.setAttribute('data-bs-toggle', 'tooltip');
                  gridItem.setAttribute('data-bs-html', 'true');
                  gridItem.setAttribute('title', shelf.item_names.join('<br>'));

                  new bootstrap.Tooltip(gridItem); // Initialize tooltip
              }
          }
      });

      document.addEventListener("DOMContentLoaded", function () {
          document.querySelectorAll('.input-container').forEach(function (inputContainer) {
              inputContainer.addEventListener('click', function () {
                  let button = document.querySelector('.btn-container button');
                  if (button) {
                      button.click();
                  }
              });
          });
      });

      new MultiSelectTag('items_name', {
          rounded: true,
          shadow: false,
          placeholder: 'Search',
      })

      function processUploadedItems(itemsList) {
    // Ensure we have a valid items list
    if (!itemsList || !Array.isArray(itemsList) || itemsList.length === 0) {
        return;
    }
    
    // console.log("Processing uploaded items:", itemsList);
    
    const itemsSelect = document.getElementById('items_name');
    if (!itemsSelect) {
        // console.error("Items select element not found");
        return;
    }
    
    // Clear previous selections
    for (let option of itemsSelect.options) {
        option.selected = false;
    }
    
    // Match and select items
    let matchCount = 0;
    for (const uploadedItem of itemsList) {
        // Normalize uploaded item name for matching
        const normalizedUploadedName = uploadedItem.toLowerCase().trim();
        
        // Check each option in the dropdown
        for (const option of itemsSelect.options) {
            // Extract item name from option text (remove price part)
            const optionText = option.textContent.trim();
            const itemName = optionText.split('(')[0].trim().toLowerCase();
            
            // Check if the uploaded item name is contained in the option name
            if (itemName.includes(normalizedUploadedName) || normalizedUploadedName.includes(itemName)) {
                option.selected = true;
                matchCount++;
                // console.log(`Matched: "${uploadedItem}" with "${optionText}"`);
                break; // Move to next uploaded item
            }
        }
    }
    
    // Refresh the MultiSelectTag UI
    // Need to dispatch an 'input' event to make MultiSelectTag update
    const inputEvent = new Event('input', { bubbles: true });
    itemsSelect.dispatchEvent(inputEvent);
    
    // Remove and re-initialize MultiSelectTag
    const multiSelectContainer = document.querySelector('.mult-select-tag');
    if (multiSelectContainer) {
        multiSelectContainer.remove();
    }
    
    new MultiSelectTag('items_name', {
        rounded: true,
        shadow: false,
        placeholder: 'Search',
    });

    document.addEventListener("DOMContentLoaded", function () {
          document.querySelectorAll('.input-container').forEach(function (inputContainer) {
              inputContainer.addEventListener('click', function () {
                  let button = document.querySelector('.btn-container button');
                  if (button) {
                      button.click();
                  }
              });
          });
      });
    
    // Show feedback to user
    // alert(`Found ${matchCount} matching items from your uploaded list.`);
    
    // If items were matched, automatically trigger Find Route
    if (matchCount > 0) {
        const findRouteBtn = document.getElementById('findRoute');
        if (findRouteBtn) {
            // Wait a moment for the UI to update before clicking
            setTimeout(() => findRouteBtn.click(), 500);
        }
    }
}

document.addEventListener('DOMContentLoaded', function() {
    // Option 1: Check URL parameters for uploaded items
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('uploaded_items')) {
        try {
            const uploadedItems = JSON.parse(decodeURIComponent(urlParams.get('uploaded_items')));
            processUploadedItems(uploadedItems);
        } catch (e) {
            console.error("Error parsing uploaded items from URL:", e);
        }
    }
    
    // Option 2: Check for uploaded items in sessionStorage
    const storedItems = sessionStorage.getItem('uploadedItems');
    if (storedItems) {
        try {
            const uploadedItems = JSON.parse(storedItems);
            processUploadedItems(uploadedItems);
            // Clear after processing
            sessionStorage.removeItem('uploadedItems');
        } catch (e) {
            console.error("Error parsing uploaded items from sessionStorage:", e);
        }
    }
});






//   7
// Supermarket Navigation Script

// document.addEventListener('DOMContentLoaded', function() {
//     const findRouteBtn = document.getElementById('findRoute');
//     const itemsSelect = document.getElementById('items_name');
//     const gridContainer = document.getElementById('grid-container');

//     class SupermarketNavigator {
//         constructor(floor, width, length) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//         }

 
//         findShelvesWithItems(selectedItemIds) {
//     // console.log("🚀 Selected Item IDs:", selectedItemIds);

//     const shelves = [];
//     const selectedItemStrings = selectedItemIds.map(id => id.toString());  // Ensure string comparison

//     Object.entries(this.floor).forEach(([index, cell]) => {
//         if (cell.mode === 'shelf') {
//             // console.log(`📍 Checking shelf at index ${index}:`, cell);

//             if (Array.isArray(cell.itemIds) && cell.itemIds.length > 0) {
//                 const cellItemStrings = cell.itemIds.map(id => id.toString());  // Convert all to strings
//                 // console.log(`🛒 Shelf ${index} contains items:`, cellItemStrings);

//                 // Compare selected item IDs with the shelf items
//                 const matchedItems = cellItemStrings.filter(id => selectedItemStrings.includes(id));

//                 if (matchedItems.length > 0) {
//                     // console.log(`✅ Match found at index ${index}:`, matchedItems);
//                     const row = Math.floor(index / this.width);
//                     const col = index % this.width;
//                     shelves.push({ index: parseInt(index), row, col, items: matchedItems });
//                 }
//             }
//         }
//     });

//     // console.log("🏁 Shelves Found:", shelves);
//     return shelves;
// }


//         // Find first cell of a specific mode
//         findFirstCellOfMode(mode) {
//             for (const [index, cell] of Object.entries(this.floor)) {
//                 if (cell.mode === mode) {
//                     const row = Math.floor(index / this.width);
//                     const col = index % this.width;
//                     return { index: parseInt(index), row, col };
//                 }
//             }
//             return null;
//         }
//     }

//     class GridPathFinder {
//     constructor(floor, width, length, selectedItemIds) {
//         this.floor = floor;
//         this.width = width;
//         this.length = length;
//         this.selectedItemIds = selectedItemIds.map(id => id.toString());
//         this.grid = this.createNavigationGrid();
//     }

//     // Create a navigation grid with intelligent routing
//     createNavigationGrid() {
//         const grid = Array(this.length).fill().map(() => 
//             Array(this.width).fill(true)
//         );

//         Object.entries(this.floor).forEach(([index, cell]) => {
//             const row = Math.floor(index / this.width);
//             const col = index % this.width;

//             // Block walls completely
//             if (cell.mode === 'wall') {
//                 grid[row][col] = false;
//             }

//             // Special handling for shelves
//             if (cell.mode === 'shelf') {
//                 // If shelf has no items or no matching selected items, block it
//                 if (!cell.itemIds || !cell.itemIds.some(id => 
//                     this.selectedItemIds.includes(id.toString())
//                 )) {
//                     grid[row][col] = false;
//                 }
//             }

//             // Block checkout and cart areas
//             if (cell.mode === 'checkout' || cell.mode === 'cart') {
//                 grid[row][col] = false;
//             }
//         });

//         return grid;
//     }

//     // A* Pathfinding algorithm with flexible routing
//     findPath(start, end) {
//         const startRow = Math.floor(start / this.width);
//         const startCol = start % this.width;
//         const endRow = Math.floor(end / this.width);
//         const endCol = end % this.width;

//         const queue = [[startRow, startCol, [start]]];
//         const visited = new Set([`${startRow},${startCol}`]);

//         while (queue.length > 0) {
//             // Sort queue by heuristic (closest to end point)
//             queue.sort((a, b) => this.heuristic(a, endRow, endCol) - this.heuristic(b, endRow, endCol));
            
//             const [row, col, path] = queue.shift();

//             // Reached destination
//             if (row === endRow && col === endCol) {
//                 return path;
//             }

//             // Check adjacent cells (up, right, down, left)
//             const directions = [
//                 [-1, 0], [0, 1], [1, 0], [0, -1]
//             ];

//             for (const [dx, dy] of directions) {
//                 const newRow = row + dx;
//                 const newCol = col + dy;
//                 const newIndex = newRow * this.width + newCol;

//                 // Validate new cell
//                 if (this.isValidCell(newRow, newCol) && 
//                     this.grid[newRow][newCol] && 
//                     !visited.has(`${newRow},${newCol}`)) {
                    
//                     visited.add(`${newRow},${newCol}`);
//                     queue.push([
//                         newRow, 
//                         newCol, 
//                         [...path, newIndex]
//                     ]);
//                 }
//             }
//         }

//         return null; // No path found
//     }

//     // Check if cell is within grid bounds
//     isValidCell(row, col) {
//         return row >= 0 && row < this.length && 
//                col >= 0 && col < this.width;
//     }

//     // Manhattan distance heuristic
//     heuristic([row, col], endRow, endCol) {
//         return Math.abs(row - endRow) + Math.abs(col - endCol);
//     }
// }


// class RouteVisualizer {
//     constructor(gridContainer, width) {
//         this.gridContainer = gridContainer;
//         this.width = width;
//         this.svgContainer = null;
//     }

//     // Improved grid item center calculation with more robust error handling
//     getGridItemCenter(index) {
//         if (index === undefined || index === null) {
//             // console.error('Invalid index provided');
//             return null;
//         }

//         const gridItem = this.gridContainer.children[index];
//         if (!gridItem) {
//             // console.error(`No grid item found for index ${index}`);
//             return null;
//         }

//         const containerRect = this.gridContainer.getBoundingClientRect();
//         const itemRect = gridItem.getBoundingClientRect();

//         return {
//             x: itemRect.left - containerRect.left + itemRect.width / 2,
//             y: itemRect.top - containerRect.top + itemRect.height / 2
//         };
//     }

//     // Create full-screen SVG container
//     createSVGContainer() {
//         // Remove any existing SVG
//         const existingSvg = this.gridContainer.querySelector('svg.route-svg');
//         if (existingSvg) existingSvg.remove();

//         const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
//         svg.classList.add('route-svg');
//         svg.style.position = 'absolute';
//         svg.style.top = '0';
//         svg.style.left = '0';
//         svg.style.width = '100%';
//         svg.style.height = '100%';
//         svg.style.pointerEvents = 'none';
//         svg.style.zIndex = '45';

//         this.gridContainer.style.position = 'relative';
//         this.gridContainer.appendChild(svg);
//         this.svgContainer = svg;

//         return svg;
//     }

//     // Create marker for arrows
//     createArrowMarker(svg) {
//         const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        
//         // Gradient marker
//         const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
//         linearGradient.setAttribute('id', 'blueGradient');
//         linearGradient.setAttribute('x1', '0%');
//         linearGradient.setAttribute('y1', '0%');
//         linearGradient.setAttribute('x2', '100%');
//         linearGradient.setAttribute('y2', '0%');

//         const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//         stop1.setAttribute('offset', '0%');
//         stop1.setAttribute('stop-color', '#3498db');

//         const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//         stop2.setAttribute('offset', '100%');
//         stop2.setAttribute('stop-color', '#2ecc71');

//         linearGradient.appendChild(stop1);
//         linearGradient.appendChild(stop2);

//         // Arrowhead marker
//         const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
//         marker.setAttribute('id', 'arrow');
//         marker.setAttribute('markerWidth', '10');
//         marker.setAttribute('markerHeight', '7');
//         marker.setAttribute('refX', '5');
//         marker.setAttribute('refY', '3.5');
//         marker.setAttribute('orient', 'auto');

//         const arrowhead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
//         arrowhead.setAttribute('points', '0 0, 10 3.5, 0 7');
//         arrowhead.setAttribute('fill', 'url(#blueGradient)');

//         marker.appendChild(arrowhead);
//         defs.appendChild(linearGradient);
//         defs.appendChild(marker);

//         svg.appendChild(defs);
//     }

//     // Draw path between two points
//     drawRoutePath(start, end, svg) {
//         if (!start || !end) {
//             // console.error('Invalid start or end points');
//             return null;
//         }

//         const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
//         path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
//         path.setAttribute('stroke', 'url(#blueGradient)');
//         path.setAttribute('stroke-width', '4');
//         path.setAttribute('fill', 'none');
//         path.setAttribute('marker-end', 'url(#arrow)');

//         return path;
//     }

//     // Main route visualization method
//     visualizeRoute(route) {
//         // console.log('Visualizing route:', route);

//         // Create SVG container
//         const svg = this.createSVGContainer();

//         // Create arrow marker
//         this.createArrowMarker(svg);

//         // Highlight route cells
//         route.forEach(index => {
//             const gridItem = this.gridContainer.children[index];
//             if (gridItem) {
//                 gridItem.classList.add('route-highlight');
//             }
//         });

//         // Draw route paths
//         for (let i = 0; i < route.length - 1; i++) {
//             const start = this.getGridItemCenter(route[i]);
//             const end = this.getGridItemCenter(route[i + 1]);

//             if (start && end) {
//                 const routePath = this.drawRoutePath(start, end, svg);
//                 if (routePath) {
//                     svg.appendChild(routePath);
//                 }
//             }
//         }
//     }
// }

// // Add CSS for route highlighting
// const styleSheet = document.createElement('style');
// styleSheet.textContent = `
//     .route-highlight {
//         background-color: rgba(52, 152, 219, 0.2) !important;
//         transition: background-color 0.3s ease;
//     }
// `;
// document.head.appendChild(styleSheet);

//     findRouteBtn.addEventListener('click', function() {
//     // Get selected item IDs
//     const selectedItems = Array.from(
//         itemsSelect.selectedOptions
//     ).map(option => option.value);

//     // Validate item selection
//     if (selectedItems.length === 0) {
//         alert('Please select at least one item');
//         return;
//     }

//     // Create navigator and path finder
//     const navigator = new SupermarketNavigator(
//         {{ floor_data_json|safe }}, 
//         {{ floor.width }}, 
//         {{ floor.length }}
//     );

//     const pathFinder = new GridPathFinder(
//         {{ floor_data_json|safe }}, 
//         {{ floor.width }}, 
//         {{ floor.length }},
//         selectedItems  
//     );

//     // Find key locations
//     const entrance = navigator.findFirstCellOfMode('entrance');
//     // console.log('entrance: ',entrance);
//     const cart = navigator.findFirstCellOfMode('cart');
//     const checkout = navigator.findFirstCellOfMode('checkout');
//     const exit = navigator.findFirstCellOfMode('exit');

//     // Find shelves with selected items
//     const itemShelves = navigator.findShelvesWithItems(selectedItems);

//     // Validate location finding
//     if (!entrance || !cart || !checkout || !exit || itemShelves.length === 0) {
//         alert('Could not find all required locations or items');
//         return;
//     }

//     // // Construct route with clear, logical flow
//     // let fullRoute = [];
//     // let currentLocation = entrance.index;

//     let currentLocation = entrance.index;
//     // console.log('Starting from entrance at index:', currentLocation);

//     // Construct route with clear, logical flow
//     let fullRoute = [currentLocation];

//     // 1. Route from entrance to cart
//     const toCartPath = pathFinder.findPath(currentLocation, cart.index);
//     fullRoute = fullRoute.concat(toCartPath);
//     currentLocation = cart.index;

//     // 2. Route from cart to each item shelf in order
//     itemShelves.forEach(shelfLocation => {
//         const toShelfPath = pathFinder.findPath(currentLocation, shelfLocation.index);
//         fullRoute = fullRoute.concat(toShelfPath);
//         currentLocation = shelfLocation.index;
//     });

//     // 3. Route from last shelf to checkout
//     // const toCheckoutPath = pathFinder.findPath(currentLocation, checkout.index);
//     // fullRoute = fullRoute.concat(toCheckoutPath);
//     // currentLocation = checkout.index;

//     // 4. Route from checkout to exit
//     const toExitPath = pathFinder.findPath(currentLocation, exit.index);
//     fullRoute = fullRoute.concat(toExitPath);

//     // Visualize route
//     const visualizer = new RouteVisualizer(gridContainer, {{ floor.width }});
//     visualizer.visualizeRoute(fullRoute);
// });


// });





// --------------------------
// 8
//   Enhanced Supermarket Navigation Script with Multi-Objective A*
// document.addEventListener('DOMContentLoaded', function() {
//     const findRouteBtn = document.getElementById('findRoute');
//     const itemsSelect = document.getElementById('items_name');
//     const gridContainer = document.getElementById('grid-container');

//     class SupermarketNavigator {
//         constructor(floor, width, length) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//         }

//         findShelvesWithItems(selectedItemIds) {
//             const shelves = [];
//             const selectedItemStrings = selectedItemIds.map(id => id.toString());

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 if (cell.mode === 'shelf') {
//                     if (Array.isArray(cell.itemIds) && cell.itemIds.length > 0) {
//                         const cellItemStrings = cell.itemIds.map(id => id.toString());
//                         const matchedItems = cellItemStrings.filter(id => selectedItemStrings.includes(id));

//                         if (matchedItems.length > 0) {
//                             const row = Math.floor(index / this.width);
//                             const col = index % this.width;
//                             shelves.push({ index: parseInt(index), row, col, items: matchedItems });
//                         }
//                     }
//                 }
//             });

//             return shelves;
//         }

//         findFirstCellOfMode(mode) {
//             for (const [index, cell] of Object.entries(this.floor)) {
//                 if (cell.mode === mode) {
//                     const row = Math.floor(index / this.width);
//                     const col = index % this.width;
//                     return { index: parseInt(index), row, col };
//                 }
//             }
//             return null;
//         }
//     }

//     // 1 - not working
//     // // RESEARCH CONTRIBUTION: Enhanced Multi-Objective A* Algorithm
//     // class MultiObjectiveAStar {
//     //     constructor(floor, width, length, selectedItemIds) {
//     //         this.floor = floor;
//     //         this.width = width;
//     //         this.length = length;
//     //         this.selectedItemIds = selectedItemIds.map(id => id.toString());
            
//     //         // NOVEL: Multi-objective optimization weights
//     //         this.weights = {
//     //             distance: 1.0,          // Base pathfinding weight
//     //             congestion: 0.4,        // Avoid crowded areas
//     //             accessibility: 0.3,     // Prefer easily accessible shelves
//     //             shoppingFlow: 0.2,      // Follow natural shopping patterns
//     //             turnPenalty: 0.15       // Minimize direction changes
//     //         };
            
//     //         // NOVEL: Initialize congestion and accessibility matrices
//     //         this.congestionMatrix = this.initializeCongestionMatrix();
//     //         this.accessibilityMatrix = this.initializeAccessibilityMatrix();
            
//     //         this.grid = this.createEnhancedNavigationGrid();
//     //     }

//     //     // NOVEL: Enhanced grid creation with partial blocking
//     //     createEnhancedNavigationGrid() {
//     //         const grid = Array(this.length).fill().map(() => 
//     //             Array(this.width).fill({ passable: true, cost: 1.0 })
//     //         );

//     //         Object.entries(this.floor).forEach(([index, cell]) => {
//     //             const row = Math.floor(index / this.width);
//     //             const col = index % this.width;

//     //             if (cell.mode === 'wall') {
//     //                 grid[row][col] = { passable: false, cost: Infinity };
//     //             }
//     //             else if (cell.mode === 'shelf') {
//     //                 const hasRequiredItems = cell.itemIds && 
//     //                     cell.itemIds.some(id => this.selectedItemIds.includes(id.toString()));
                    
//     //                 if (hasRequiredItems) {
//     //                     // Target shelf - low cost
//     //                     grid[row][col] = { passable: true, cost: 0.5 };
//     //                 } else {
//     //                     // Non-target shelf - higher cost but passable
//     //                     grid[row][col] = { passable: true, cost: 2.0 };
//     //                 }
//     //             }
//     //             else if (cell.mode === 'checkout' || cell.mode === 'cart') {
//     //                 grid[row][col] = { passable: false, cost: Infinity };
//     //             }
//     //             else {
//     //                 // Open space - apply congestion-based cost
//     //                 const congestionLevel = this.getCongestionLevel(row, col);
//     //                 grid[row][col] = { 
//     //                     passable: true, 
//     //                     cost: 1.0 + (congestionLevel * 0.5) 
//     //                 };
//     //             }
//     //         });

//     //         return grid;
//     //     }

//     //     // NOVEL: Multi-objective heuristic function
//     //     multiObjectiveHeuristic(current, goal, gScore, path) {
//     //         const [currentRow, currentCol] = current;
//     //         const [goalRow, goalCol] = goal;
            
//     //         // 1. Base Manhattan distance
//     //         const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
            
//     //         // 2. NOVEL: Congestion penalty
//     //         const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
            
//     //         // 3. NOVEL: Accessibility bonus for target shelves
//     //         const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
            
//     //         // 4. NOVEL: Shopping flow optimization
//     //         const flowBonus = this.getShoppingFlowBonus(current, goal);
            
//     //         // 5. NOVEL: Turn penalty based on path history
//     //         const turnPenalty = this.calculateTurnPenalty(path, current);
            
//     //         // Combine all objectives with weights
//     //         const heuristic = 
//     //             (this.weights.distance * manhattanDistance) +
//     //             (this.weights.congestion * congestionPenalty) -
//     //             (this.weights.accessibility * accessibilityBonus) -
//     //             (this.weights.shoppingFlow * flowBonus) +
//     //             (this.weights.turnPenalty * turnPenalty);
            
//     //         return Math.max(0, heuristic);
//     //     }

//     //     // NOVEL: Enhanced A* with multi-objective optimization
//     //     findOptimalPath(start, end) {
//     //         const startRow = Math.floor(start / this.width);
//     //         const startCol = start % this.width;
//     //         const endRow = Math.floor(end / this.width);
//     //         const endCol = end % this.width;

//     //         // Priority queue with enhanced node structure
//     //         const openList = [{
//     //             position: [startRow, startCol],
//     //             path: [start],
//     //             gScore: 0,
//     //             fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
//     //             parent: null
//     //         }];
            
//     //         const closedList = new Set();
//     //         const bestGScores = new Map(); // Track best g-scores for positions

//     //         while (openList.length > 0) {
//     //             // Sort by f-score (multi-objective heuristic)
//     //             openList.sort((a, b) => a.fScore - b.fScore);
//     //             const current = openList.shift();
                
//     //             const [row, col] = current.position;
//     //             const positionKey = `${row},${col}`;

//     //             if (closedList.has(positionKey)) continue;
//     //             closedList.add(positionKey);

//     //             // Goal reached
//     //             if (row === endRow && col === endCol) {
//     //                 return current.path;
//     //             }

//     //             // Explore neighbors with enhanced cost calculation
//     //             const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//     //             for (const [dx, dy] of directions) {
//     //                 const newRow = row + dx;
//     //                 const newCol = col + dy;
//     //                 const newIndex = newRow * this.width + newCol;
//     //                 const newPositionKey = `${newRow},${newCol}`;

//     //                 if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
//     //                     continue;
//     //                 }

//     //                 // NOVEL: Dynamic cost calculation
//     //                 const moveCost = this.calculateEnhancedMoveCost(
//     //                     [row, col], 
//     //                     [newRow, newCol], 
//     //                     current.path
//     //                 );

//     //                 const newGScore = current.gScore + moveCost;
//     //                 const newPath = [...current.path, newIndex];
                    
//     //                 // Check if we've found a better path to this position
//     //                 const bestG = bestGScores.get(newPositionKey);
//     //                 if (bestG !== undefined && newGScore >= bestG) {
//     //                     continue;
//     //                 }
//     //                 bestGScores.set(newPositionKey, newGScore);

//     //                 const newFScore = newGScore + this.multiObjectiveHeuristic(
//     //                     [newRow, newCol], 
//     //                     [endRow, endCol], 
//     //                     newGScore,
//     //                     newPath
//     //                 );

//     //                 // Remove any existing node with same position but higher cost
//     //                 const existingIndex = openList.findIndex(node => 
//     //                     node.position[0] === newRow && node.position[1] === newCol
//     //                 );
                    
//     //                 if (existingIndex !== -1) {
//     //                     if (newGScore < openList[existingIndex].gScore) {
//     //                         openList.splice(existingIndex, 1);
//     //                     } else {
//     //                         continue;
//     //                     }
//     //                 }

//     //                 openList.push({
//     //                     position: [newRow, newCol],
//     //                     path: newPath,
//     //                     gScore: newGScore,
//     //                     fScore: newFScore,
//     //                     parent: current
//     //                 });
//     //             }
//     //         }

//     //         return null; // No path found
//     //     }

//     //     // NOVEL: Enhanced move cost calculation
//     //     calculateEnhancedMoveCost(from, to, currentPath) {
//     //         const [toRow, toCol] = to;
            
//     //         // Base movement cost from grid
//     //         const gridCell = this.grid[toRow][toCol];
//     //         let baseCost = gridCell.cost;
            
//     //         // NOVEL: Congestion multiplier
//     //         const congestionLevel = this.getCongestionLevel(toRow, toCol);
//     //         const congestionMultiplier = 1 + (congestionLevel * 0.3);
            
//     //         // NOVEL: Turn penalty
//     //         const turnPenalty = this.getDirectionChangePenalty(currentPath, to);
            
//     //         // NOVEL: Accessibility bonus for shelves with required items
//     //         const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
            
//     //         return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
//     //     }

//     //     // NOVEL METHODS: Supporting functions for multi-objective optimization

//     //     initializeCongestionMatrix() {
//     //         // Simulate congestion patterns based on typical supermarket flow
//     //         const matrix = Array(this.length).fill().map(() => Array(this.width).fill(0));
            
//     //         // Higher congestion in central aisles and near entrance/checkout
//     //         for (let i = 0; i < this.length; i++) {
//     //             for (let j = 0; j < this.width; j++) {
//     //                 // Central areas have higher congestion
//     //                 const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
//     //                 const maxDistance = (this.length + this.width) / 2;
//     //                 matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
                    
//     //                 // Add some randomness for realistic patterns
//     //                 matrix[i][j] += Math.random() * 0.2;
//     //             }
//     //         }
            
//     //         return matrix;
//     //     }

//     //     initializeAccessibilityMatrix() {
//     //         const matrix = Array(this.length).fill().map(() => Array(this.width).fill(0));
            
//     //         Object.entries(this.floor).forEach(([index, cell]) => {
//     //             const row = Math.floor(index / this.width);
//     //             const col = index % this.width;
                
//     //             if (cell.mode === 'shelf' && cell.itemIds) {
//     //                 const hasRequiredItems = cell.itemIds.some(id => 
//     //                     this.selectedItemIds.includes(id.toString())
//     //                 );
                    
//     //                 if (hasRequiredItems) {
//     //                     // Calculate accessibility based on surrounding free spaces
//     //                     let freeSpaces = 0;
//     //                     const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        
//     //                     for (const [dx, dy] of directions) {
//     //                         const checkRow = row + dx;
//     //                         const checkCol = col + dy;
//     //                         if (this.isValidMove(checkRow, checkCol) && 
//     //                             this.grid[checkRow][checkCol].passable) {
//     //                             freeSpaces++;
//     //                         }
//     //                     }
                        
//     //                     matrix[row][col] = freeSpaces / 4.0; // Normalize to 0-1
//     //                 }
//     //             }
//     //         });
            
//     //         return matrix;
//     //     }

//     //     getCongestionLevel(row, col) {
//     //         if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
//     //             return this.congestionMatrix[row][col];
//     //         }
//     //         return 0;
//     //     }

//     //     getAccessibilityBonus(row, col) {
//     //         if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
//     //             return this.accessibilityMatrix[row][col];
//     //         }
//     //         return 0;
//     //     }

//     //     getShoppingFlowBonus(current, goal) {
//     //         const [currentRow, currentCol] = current;
//     //         const [goalRow, goalCol] = goal;
            
//     //         // NOVEL: Prefer perimeter-to-interior shopping pattern
//     //         const currentPerimeterDistance = Math.min(
//     //             currentRow, currentCol, 
//     //             this.length - 1 - currentRow, 
//     //             this.width - 1 - currentCol
//     //         );
            
//     //         const goalPerimeterDistance = Math.min(
//     //             goalRow, goalCol, 
//     //             this.length - 1 - goalRow, 
//     //             this.width - 1 - goalCol
//     //         );
            
//     //         // Bonus for moving from perimeter towards interior
//     //         if (currentPerimeterDistance <= goalPerimeterDistance) {
//     //             return 0.3;
//     //         }
            
//     //         return 0;
//     //     }

//     //     calculateTurnPenalty(path, current) {
//     //         if (path.length < 2) return 0;
            
//     //         const [currentRow, currentCol] = current;
//     //         const lastIndex = path[path.length - 1];
//     //         const secondLastIndex = path[path.length - 2];
            
//     //         const lastRow = Math.floor(lastIndex / this.width);
//     //         const lastCol = lastIndex % this.width;
//     //         const secondLastRow = Math.floor(secondLastIndex / this.width);
//     //         const secondLastCol = secondLastIndex % this.width;
            
//     //         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//     //         const newDirection = [currentRow - lastRow, currentCol - lastCol];
            
//     //         // Penalty for direction changes
//     //         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//     //             return 0.2;
//     //         }
            
//     //         return 0;
//     //     }

//     //     getDirectionChangePenalty(path, newPosition) {
//     //         if (path.length < 2) return 0;
            
//     //         const [newRow, newCol] = newPosition;
//     //         const lastIndex = path[path.length - 1];
//     //         const secondLastIndex = path[path.length - 2];
            
//     //         const lastRow = Math.floor(lastIndex / this.width);
//     //         const lastCol = lastIndex % this.width;
//     //         const secondLastRow = Math.floor(secondLastIndex / this.width);
//     //         const secondLastCol = secondLastIndex % this.width;
            
//     //         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//     //         const newDirection = [newRow - lastRow, newCol - lastCol];
            
//     //         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//     //             return 0.15; // Turn penalty
//     //         }
            
//     //         return 0;
//     //     }

//     //     isValidMove(row, col) {
//     //         return row >= 0 && row < this.length && 
//     //                col >= 0 && col < this.width && 
//     //                this.grid[row][col].passable;
//     //     }
//     // }


//     // 2 - working - going on the shelves
//     // Fixed Multi-Objective A* Algorithm
// // class MultiObjectiveAStar {
// //     constructor(floor, width, length, selectedItemIds) {
// //         this.floor = floor;
// //         this.width = width;
// //         this.length = length;
// //         this.selectedItemIds = selectedItemIds.map(id => id.toString());
        
// //         // Multi-objective optimization weights
// //         this.weights = {
// //             distance: 1.0,          // Base pathfinding weight
// //             congestion: 0.4,        // Avoid crowded areas
// //             accessibility: 0.3,     // Prefer easily accessible shelves
// //             shoppingFlow: 0.2,      // Follow natural shopping patterns
// //             turnPenalty: 0.15       // Minimize direction changes
// //         };
        
// //         // FIXED: Initialize grid FIRST, then matrices that depend on it
// //         this.grid = this.createEnhancedNavigationGrid();
// //         this.congestionMatrix = this.initializeCongestionMatrix();
// //         this.accessibilityMatrix = this.initializeAccessibilityMatrix();
// //     }

// //     // Enhanced grid creation with partial blocking
// //     createEnhancedNavigationGrid() {
// //         const grid = Array(this.length).fill(null).map(() => 
// //             Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
// //         );

// //         Object.entries(this.floor).forEach(([index, cell]) => {
// //             const row = Math.floor(index / this.width);
// //             const col = index % this.width;

// //             // Bounds check
// //             if (row >= this.length || col >= this.width || row < 0 || col < 0) {
// //                 console.warn(`Invalid grid position: row=${row}, col=${col}`);
// //                 return;
// //             }

// //             if (cell.mode === 'wall') {
// //                 grid[row][col] = { passable: false, cost: Infinity };
// //             }
// //             else if (cell.mode === 'shelf') {
// //                 const hasRequiredItems = cell.itemIds && 
// //                     cell.itemIds.some(id => this.selectedItemIds.includes(id.toString()));
                
// //                 if (hasRequiredItems) {
// //                     // Target shelf - low cost
// //                     grid[row][col] = { passable: true, cost: 0.5 };
// //                 } else {
// //                     // Non-target shelf - higher cost but passable
// //                     grid[row][col] = { passable: true, cost: 2.0 };
// //                 }
// //             }
// //             else if (cell.mode === 'checkout' || cell.mode === 'cart') {
// //                 grid[row][col] = { passable: false, cost: Infinity };
// //             }
// //             else {
// //                 // Open space - will apply congestion-based cost later
// //                 grid[row][col] = { passable: true, cost: 1.0 };
// //             }
// //         });

// //         return grid;
// //     }

// //     // Multi-objective heuristic function
// //     multiObjectiveHeuristic(current, goal, gScore, path) {
// //         const [currentRow, currentCol] = current;
// //         const [goalRow, goalCol] = goal;
        
// //         // 1. Base Manhattan distance
// //         const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
        
// //         // 2. Congestion penalty
// //         const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
        
// //         // 3. Accessibility bonus for target shelves
// //         const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
        
// //         // 4. Shopping flow optimization
// //         const flowBonus = this.getShoppingFlowBonus(current, goal);
        
// //         // 5. Turn penalty based on path history
// //         const turnPenalty = this.calculateTurnPenalty(path, current);
        
// //         // Combine all objectives with weights
// //         const heuristic = 
// //             (this.weights.distance * manhattanDistance) +
// //             (this.weights.congestion * congestionPenalty) -
// //             (this.weights.accessibility * accessibilityBonus) -
// //             (this.weights.shoppingFlow * flowBonus) +
// //             (this.weights.turnPenalty * turnPenalty);
        
// //         return Math.max(0, heuristic);
// //     }

// //     // Enhanced A* with multi-objective optimization
// //     findOptimalPath(start, end) {
// //         const startRow = Math.floor(start / this.width);
// //         const startCol = start % this.width;
// //         const endRow = Math.floor(end / this.width);
// //         const endCol = end % this.width;

// //         // Validate start and end positions
// //         if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
// //             console.error('Invalid start or end position');
// //             return null;
// //         }

// //         // Priority queue with enhanced node structure
// //         const openList = [{
// //             position: [startRow, startCol],
// //             path: [start],
// //             gScore: 0,
// //             fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
// //             parent: null
// //         }];
        
// //         const closedList = new Set();
// //         const bestGScores = new Map();

// //         while (openList.length > 0) {
// //             // Sort by f-score (multi-objective heuristic)
// //             openList.sort((a, b) => a.fScore - b.fScore);
// //             const current = openList.shift();
            
// //             const [row, col] = current.position;
// //             const positionKey = `${row},${col}`;

// //             if (closedList.has(positionKey)) continue;
// //             closedList.add(positionKey);

// //             // Goal reached
// //             if (row === endRow && col === endCol) {
// //                 return current.path;
// //             }

// //             // Explore neighbors with enhanced cost calculation
// //             const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
            
// //             for (const [dx, dy] of directions) {
// //                 const newRow = row + dx;
// //                 const newCol = col + dy;
// //                 const newIndex = newRow * this.width + newCol;
// //                 const newPositionKey = `${newRow},${newCol}`;

// //                 if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
// //                     continue;
// //                 }

// //                 // Dynamic cost calculation
// //                 const moveCost = this.calculateEnhancedMoveCost(
// //                     [row, col], 
// //                     [newRow, newCol], 
// //                     current.path
// //                 );

// //                 const newGScore = current.gScore + moveCost;
// //                 const newPath = [...current.path, newIndex];
                
// //                 // Check if we've found a better path to this position
// //                 const bestG = bestGScores.get(newPositionKey);
// //                 if (bestG !== undefined && newGScore >= bestG) {
// //                     continue;
// //                 }
// //                 bestGScores.set(newPositionKey, newGScore);

// //                 const newFScore = newGScore + this.multiObjectiveHeuristic(
// //                     [newRow, newCol], 
// //                     [endRow, endCol], 
// //                     newGScore,
// //                     newPath
// //                 );

// //                 // Remove any existing node with same position but higher cost
// //                 const existingIndex = openList.findIndex(node => 
// //                     node.position[0] === newRow && node.position[1] === newCol
// //                 );
                
// //                 if (existingIndex !== -1) {
// //                     if (newGScore < openList[existingIndex].gScore) {
// //                         openList.splice(existingIndex, 1);
// //                     } else {
// //                         continue;
// //                     }
// //                 }

// //                 openList.push({
// //                     position: [newRow, newCol],
// //                     path: newPath,
// //                     gScore: newGScore,
// //                     fScore: newFScore,
// //                     parent: current
// //                 });
// //             }
// //         }

// //         return null; // No path found
// //     }

// //     // Enhanced move cost calculation
// //     calculateEnhancedMoveCost(from, to, currentPath) {
// //         const [toRow, toCol] = to;
        
// //         // Base movement cost from grid
// //         const gridCell = this.grid[toRow][toCol];
// //         let baseCost = gridCell.cost;
        
// //         // Congestion multiplier
// //         const congestionLevel = this.getCongestionLevel(toRow, toCol);
// //         const congestionMultiplier = 1 + (congestionLevel * 0.3);
        
// //         // Turn penalty
// //         const turnPenalty = this.getDirectionChangePenalty(currentPath, [toRow, toCol]);
        
// //         // Accessibility bonus for shelves with required items
// //         const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
        
// //         return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
// //     }

// //     // FIXED: Proper bounds checking
// //     isValidMove(row, col) {
// //         if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
// //             return false;
// //         }
        
// //         if (!this.grid || !this.grid[row] || !this.grid[row][col]) {
// //             return false;
// //         }
        
// //         return this.grid[row][col].passable;
// //     }

// //     // Supporting functions for multi-objective optimization
// //     initializeCongestionMatrix() {
// //         const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
        
// //         // Higher congestion in central aisles and near entrance/checkout
// //         for (let i = 0; i < this.length; i++) {
// //             for (let j = 0; j < this.width; j++) {
// //                 // Central areas have higher congestion
// //                 const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
// //                 const maxDistance = (this.length + this.width) / 2;
// //                 matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
                
// //                 // Add some randomness for realistic patterns
// //                 matrix[i][j] += Math.random() * 0.2;
// //             }
// //         }
        
// //         return matrix;
// //     }

// //     initializeAccessibilityMatrix() {
// //         const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
        
// //         Object.entries(this.floor).forEach(([index, cell]) => {
// //             const row = Math.floor(index / this.width);
// //             const col = index % this.width;
            
// //             // Bounds check
// //             if (row >= this.length || col >= this.width || row < 0 || col < 0) {
// //                 return;
// //             }
            
// //             if (cell.mode === 'shelf' && cell.itemIds) {
// //                 const hasRequiredItems = cell.itemIds.some(id => 
// //                     this.selectedItemIds.includes(id.toString())
// //                 );
                
// //                 if (hasRequiredItems) {
// //                     // Calculate accessibility based on surrounding free spaces
// //                     let freeSpaces = 0;
// //                     const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                    
// //                     for (const [dx, dy] of directions) {
// //                         const checkRow = row + dx;
// //                         const checkCol = col + dy;
// //                         if (this.isValidPosition(checkRow, checkCol)) {
// //                             freeSpaces++;
// //                         }
// //                     }
                    
// //                     matrix[row][col] = freeSpaces / 4.0; // Normalize to 0-1
// //                 }
// //             }
// //         });
        
// //         return matrix;
// //     }

// //     // FIXED: Separate method for position validation (doesn't depend on grid passability)
// //     isValidPosition(row, col) {
// //         return row >= 0 && row < this.length && col >= 0 && col < this.width;
// //     }

// //     getCongestionLevel(row, col) {
// //         if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
// //             return this.congestionMatrix[row][col];
// //         }
// //         return 0;
// //     }

// //     getAccessibilityBonus(row, col) {
// //         if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
// //             return this.accessibilityMatrix[row][col];
// //         }
// //         return 0;
// //     }

// //     getShoppingFlowBonus(current, goal) {
// //         const [currentRow, currentCol] = current;
// //         const [goalRow, goalCol] = goal;
        
// //         // Prefer perimeter-to-interior shopping pattern
// //         const currentPerimeterDistance = Math.min(
// //             currentRow, currentCol, 
// //             this.length - 1 - currentRow, 
// //             this.width - 1 - currentCol
// //         );
        
// //         const goalPerimeterDistance = Math.min(
// //             goalRow, goalCol, 
// //             this.length - 1 - goalRow, 
// //             this.width - 1 - goalCol
// //         );
        
// //         // Bonus for moving from perimeter towards interior
// //         if (currentPerimeterDistance <= goalPerimeterDistance) {
// //             return 0.3;
// //         }
        
// //         return 0;
// //     }

// //     calculateTurnPenalty(path, current) {
// //         if (path.length < 2) return 0;
        
// //         const [currentRow, currentCol] = current;
// //         const lastIndex = path[path.length - 1];
// //         const secondLastIndex = path[path.length - 2];
        
// //         const lastRow = Math.floor(lastIndex / this.width);
// //         const lastCol = lastIndex % this.width;
// //         const secondLastRow = Math.floor(secondLastIndex / this.width);
// //         const secondLastCol = secondLastIndex % this.width;
        
// //         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
// //         const newDirection = [currentRow - lastRow, currentCol - lastCol];
        
// //         // Penalty for direction changes
// //         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
// //             return 0.2;
// //         }
        
// //         return 0;
// //     }

// //     getDirectionChangePenalty(path, newPosition) {
// //         if (path.length < 2) return 0;
        
// //         const [newRow, newCol] = newPosition;
// //         const lastIndex = path[path.length - 1];
// //         const secondLastIndex = path[path.length - 2];
        
// //         const lastRow = Math.floor(lastIndex / this.width);
// //         const lastCol = lastIndex % this.width;
// //         const secondLastRow = Math.floor(secondLastIndex / this.width);
// //         const secondLastCol = secondLastIndex % this.width;
        
// //         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
// //         const newDirection = [newRow - lastRow, newCol - lastCol];
        
// //         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
// //             return 0.15; // Turn penalty
// //         }
        
// //         return 0;
// //     }
// // }


//     // 3
//     // Fixed Multi-Objective A* Algorithm
// class MultiObjectiveAStar {
//     constructor(floor, width, length, selectedItemIds) {
//         this.floor = floor;
//         this.width = width;
//         this.length = length;
//         this.selectedItemIds = selectedItemIds.map(id => id.toString());
        
//         // Multi-objective optimization weights
//         this.weights = {
//             distance: 1.0,          // Base pathfinding weight
//             congestion: 0.4,        // Avoid crowded areas
//             accessibility: 0.3,     // Prefer easily accessible shelves
//             shoppingFlow: 0.2,      // Follow natural shopping patterns
//             turnPenalty: 0.15       // Minimize direction changes
//         };
        
//         // FIXED: Initialize grid FIRST, then matrices that depend on it
//         this.grid = this.createEnhancedNavigationGrid();
//         this.congestionMatrix = this.initializeCongestionMatrix();
//         this.accessibilityMatrix = this.initializeAccessibilityMatrix();
//     }

//     // Enhanced grid creation with proper blocking
//     createEnhancedNavigationGrid() {
//         const grid = Array(this.length).fill(null).map(() => 
//             Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
//         );

//         Object.entries(this.floor).forEach(([index, cell]) => {
//             const row = Math.floor(index / this.width);
//             const col = index % this.width;

//             // Bounds check
//             if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                 console.warn(`Invalid grid position: row=${row}, col=${col}`);
//                 return;
//             }

//             if (cell.mode === 'wall') {
//                 grid[row][col] = { passable: false, cost: Infinity };
//             }
//             else if (cell.mode === 'shelf') {
//                 // FIXED: ALL shelves are impassable - you can't walk through them!
//                 // We can only walk to adjacent cells to "pick up" items
//                 grid[row][col] = { passable: false, cost: Infinity };
//             }
//             else if (cell.mode === 'checkout' || cell.mode === 'cart') {
//                 // These are special locations we can reach as destinations
//                 grid[row][col] = { passable: true, cost: 1.0 };
//             }
//             else if (cell.mode === 'entrance' || cell.mode === 'exit') {
//                 // Entrance and exit points are passable
//                 grid[row][col] = { passable: true, cost: 0.8 };
//             }
//             else {
//                 // Open space - apply congestion-based cost later
//                 const congestionLevel = this.getCongestionLevel(row, col);
//                 grid[row][col] = { 
//                     passable: true, 
//                     cost: 1.0 + (congestionLevel * 0.3) 
//                 };
//             }
//         });

//         return grid;
//     }

//     // Multi-objective heuristic function
//     multiObjectiveHeuristic(current, goal, gScore, path) {
//         const [currentRow, currentCol] = current;
//         const [goalRow, goalCol] = goal;
        
//         // 1. Base Manhattan distance
//         const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
        
//         // 2. Congestion penalty
//         const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
        
//         // 3. Accessibility bonus for target shelves
//         const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
        
//         // 4. Shopping flow optimization
//         const flowBonus = this.getShoppingFlowBonus(current, goal);
        
//         // 5. Turn penalty based on path history
//         const turnPenalty = this.calculateTurnPenalty(path, current);
        
//         // Combine all objectives with weights
//         const heuristic = 
//             (this.weights.distance * manhattanDistance) +
//             (this.weights.congestion * congestionPenalty) -
//             (this.weights.accessibility * accessibilityBonus) -
//             (this.weights.shoppingFlow * flowBonus) +
//             (this.weights.turnPenalty * turnPenalty);
        
//         return Math.max(0, heuristic);
//     }

//     // NEW: Find accessible positions adjacent to target shelves
//     findAccessibleShelfPositions(shelves) {
//         const accessiblePositions = [];
        
//         shelves.forEach(shelf => {
//             const shelfRow = Math.floor(shelf.index / this.width);
//             const shelfCol = shelf.index % this.width;
            
//             // Check all 4 adjacent positions (up, right, down, left)
//             const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
            
//             for (const [dx, dy] of directions) {
//                 const adjRow = shelfRow + dx;
//                 const adjCol = shelfCol + dy;
//                 const adjIndex = adjRow * this.width + adjCol;
                
//                 // Check if adjacent position is valid and passable
//                 if (this.isValidMove(adjRow, adjCol)) {
//                     accessiblePositions.push({
//                         index: adjIndex,
//                         row: adjRow,
//                         col: adjCol,
//                         targetShelf: shelf,
//                         items: shelf.items
//                     });
//                     break; // Take the first accessible position for this shelf
//                 }
//             }
//         });
        
//         return accessiblePositions;
//     }

//     // Enhanced A* with multi-objective optimization
//     findOptimalPath(start, end) {
//         const startRow = Math.floor(start / this.width);
//         const startCol = start % this.width;
//         const endRow = Math.floor(end / this.width);
//         const endCol = end % this.width;

//         // Validate start and end positions
//         if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
//             console.error('Invalid start or end position');
//             return null;
//         }

//         // Priority queue with enhanced node structure
//         const openList = [{
//             position: [startRow, startCol],
//             path: [start],
//             gScore: 0,
//             fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
//             parent: null
//         }];
        
//         const closedList = new Set();
//         const bestGScores = new Map();

//         while (openList.length > 0) {
//             // Sort by f-score (multi-objective heuristic)
//             openList.sort((a, b) => a.fScore - b.fScore);
//             const current = openList.shift();
            
//             const [row, col] = current.position;
//             const positionKey = `${row},${col}`;

//             if (closedList.has(positionKey)) continue;
//             closedList.add(positionKey);

//             // Goal reached
//             if (row === endRow && col === endCol) {
//                 return current.path;
//             }

//             // Explore neighbors with enhanced cost calculation
//             const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
            
//             for (const [dx, dy] of directions) {
//                 const newRow = row + dx;
//                 const newCol = col + dy;
//                 const newIndex = newRow * this.width + newCol;
//                 const newPositionKey = `${newRow},${newCol}`;

//                 if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
//                     continue;
//                 }

//                 // Dynamic cost calculation
//                 const moveCost = this.calculateEnhancedMoveCost(
//                     [row, col], 
//                     [newRow, newCol], 
//                     current.path
//                 );

//                 const newGScore = current.gScore + moveCost;
//                 const newPath = [...current.path, newIndex];
                
//                 // Check if we've found a better path to this position
//                 const bestG = bestGScores.get(newPositionKey);
//                 if (bestG !== undefined && newGScore >= bestG) {
//                     continue;
//                 }
//                 bestGScores.set(newPositionKey, newGScore);

//                 const newFScore = newGScore + this.multiObjectiveHeuristic(
//                     [newRow, newCol], 
//                     [endRow, endCol], 
//                     newGScore,
//                     newPath
//                 );

//                 // Remove any existing node with same position but higher cost
//                 const existingIndex = openList.findIndex(node => 
//                     node.position[0] === newRow && node.position[1] === newCol
//                 );
                
//                 if (existingIndex !== -1) {
//                     if (newGScore < openList[existingIndex].gScore) {
//                         openList.splice(existingIndex, 1);
//                     } else {
//                         continue;
//                     }
//                 }

//                 openList.push({
//                     position: [newRow, newCol],
//                     path: newPath,
//                     gScore: newGScore,
//                     fScore: newFScore,
//                     parent: current
//                 });
//             }
//         }

//         return null; // No path found
//     }

//     // Enhanced move cost calculation
//     calculateEnhancedMoveCost(from, to, currentPath) {
//         const [toRow, toCol] = to;
        
//         // Base movement cost from grid
//         const gridCell = this.grid[toRow][toCol];
//         let baseCost = gridCell.cost;
        
//         // Congestion multiplier
//         const congestionLevel = this.getCongestionLevel(toRow, toCol);
//         const congestionMultiplier = 1 + (congestionLevel * 0.3);
        
//         // Turn penalty
//         const turnPenalty = this.getDirectionChangePenalty(currentPath, [toRow, toCol]);
        
//         // Accessibility bonus for shelves with required items
//         const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
        
//         return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
//     }

//     // FIXED: Proper bounds checking
//     isValidMove(row, col) {
//         if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
//             return false;
//         }
        
//         if (!this.grid || !this.grid[row] || !this.grid[row][col]) {
//             return false;
//         }
        
//         return this.grid[row][col].passable;
//     }

//     // Supporting functions for multi-objective optimization
//     initializeCongestionMatrix() {
//         const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
        
//         // Higher congestion in central aisles and near entrance/checkout
//         for (let i = 0; i < this.length; i++) {
//             for (let j = 0; j < this.width; j++) {
//                 // Central areas have higher congestion
//                 const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
//                 const maxDistance = (this.length + this.width) / 2;
//                 matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
                
//                 // Add some randomness for realistic patterns
//                 matrix[i][j] += Math.random() * 0.2;
//             }
//         }
        
//         return matrix;
//     }

//     initializeAccessibilityMatrix() {
//         const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
        
//         Object.entries(this.floor).forEach(([index, cell]) => {
//             const row = Math.floor(index / this.width);
//             const col = index % this.width;
            
//             // Bounds check
//             if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                 return;
//             }
            
//             if (cell.mode === 'shelf' && cell.itemIds) {
//                 const hasRequiredItems = cell.itemIds.some(id => 
//                     this.selectedItemIds.includes(id.toString())
//                 );
                
//                 if (hasRequiredItems) {
//                     // Calculate accessibility based on surrounding free spaces
//                     let freeSpaces = 0;
//                     const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                    
//                     for (const [dx, dy] of directions) {
//                         const checkRow = row + dx;
//                         const checkCol = col + dy;
//                         if (this.isValidPosition(checkRow, checkCol)) {
//                             freeSpaces++;
//                         }
//                     }
                    
//                     matrix[row][col] = freeSpaces / 4.0; // Normalize to 0-1
//                 }
//             }
//         });
        
//         return matrix;
//     }

//     // FIXED: Separate method for position validation (doesn't depend on grid passability)
//     isValidPosition(row, col) {
//         return row >= 0 && row < this.length && col >= 0 && col < this.width;
//     }

//     getCongestionLevel(row, col) {
//         if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
//             return this.congestionMatrix[row][col];
//         }
//         return 0;
//     }

//     getAccessibilityBonus(row, col) {
//         if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
//             return this.accessibilityMatrix[row][col];
//         }
//         return 0;
//     }

//     getShoppingFlowBonus(current, goal) {
//         const [currentRow, currentCol] = current;
//         const [goalRow, goalCol] = goal;
        
//         // Prefer perimeter-to-interior shopping pattern
//         const currentPerimeterDistance = Math.min(
//             currentRow, currentCol, 
//             this.length - 1 - currentRow, 
//             this.width - 1 - currentCol
//         );
        
//         const goalPerimeterDistance = Math.min(
//             goalRow, goalCol, 
//             this.length - 1 - goalRow, 
//             this.width - 1 - goalCol
//         );
        
//         // Bonus for moving from perimeter towards interior
//         if (currentPerimeterDistance <= goalPerimeterDistance) {
//             return 0.3;
//         }
        
//         return 0;
//     }

//     calculateTurnPenalty(path, current) {
//         if (path.length < 2) return 0;
        
//         const [currentRow, currentCol] = current;
//         const lastIndex = path[path.length - 1];
//         const secondLastIndex = path[path.length - 2];
        
//         const lastRow = Math.floor(lastIndex / this.width);
//         const lastCol = lastIndex % this.width;
//         const secondLastRow = Math.floor(secondLastIndex / this.width);
//         const secondLastCol = secondLastIndex % this.width;
        
//         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//         const newDirection = [currentRow - lastRow, currentCol - lastCol];
        
//         // Penalty for direction changes
//         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//             return 0.2;
//         }
        
//         return 0;
//     }

//     getDirectionChangePenalty(path, newPosition) {
//         if (path.length < 2) return 0;
        
//         const [newRow, newCol] = newPosition;
//         const lastIndex = path[path.length - 1];
//         const secondLastIndex = path[path.length - 2];
        
//         const lastRow = Math.floor(lastIndex / this.width);
//         const lastCol = lastIndex % this.width;
//         const secondLastRow = Math.floor(secondLastIndex / this.width);
//         const secondLastCol = secondLastIndex % this.width;
        
//         const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//         const newDirection = [newRow - lastRow, newCol - lastCol];
        
//         if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//             return 0.15; // Turn penalty
//         }
        
//         return 0;
//     }
// }




//     // NOVEL: Enhanced Navigator with intelligent shelf ordering
//     class EnhancedSupermarketNavigator extends SupermarketNavigator {
//         constructor(floor, width, length) {
//             super(floor, width, length);
//         }

//         // NOVEL: Optimize shelf visit order using TSP-inspired approach
//         optimizeShelfOrder(shelves, startLocation) {
//             if (shelves.length <= 1) return shelves;
            
//             // Create distance matrix between all points
//             const points = [startLocation, ...shelves];
//             const distances = this.calculateDistanceMatrix(points);
            
//             // Use nearest neighbor heuristic with shopping flow consideration
//             const optimizedOrder = [];
//             let currentIndex = 0; // Start from the starting location
//             const unvisited = new Set(Array.from({length: shelves.length}, (_, i) => i + 1));
            
//             while (unvisited.size > 0) {
//                 let nearestIndex = -1;
//                 let nearestDistance = Infinity;
                
//                 for (const index of unvisited) {
//                     let distance = distances[currentIndex][index];
                    
//                     // NOVEL: Apply shopping flow bonus
//                     const flowBonus = this.calculateShoppingFlowBonus(
//                         points[currentIndex], 
//                         points[index]
//                     );
//                     distance -= flowBonus;
                    
//                     if (distance < nearestDistance) {
//                         nearestDistance = distance;
//                         nearestIndex = index;
//                     }
//                 }
                
//                 unvisited.delete(nearestIndex);
//                 optimizedOrder.push(shelves[nearestIndex - 1]);
//                 currentIndex = nearestIndex;
//             }
            
//             return optimizedOrder;
//         }

//         calculateDistanceMatrix(points) {
//             const matrix = Array(points.length).fill().map(() => Array(points.length).fill(0));
            
//             for (let i = 0; i < points.length; i++) {
//                 for (let j = 0; j < points.length; j++) {
//                     if (i !== j) {
//                         const point1 = points[i];
//                         const point2 = points[j];
//                         matrix[i][j] = Math.abs(point1.row - point2.row) + 
//                                       Math.abs(point1.col - point2.col);
//                     }
//                 }
//             }
            
//             return matrix;
//         }

//         calculateShoppingFlowBonus(point1, point2) {
//             // Prefer top-to-bottom, left-to-right shopping patterns
//             if (point1.row <= point2.row && point1.col <= point2.col) {
//                 return 0.5;
//             }
//             return 0;
//         }
//     }

//     // Keep the existing RouteVisualizer class unchanged
//     class RouteVisualizer {
//         constructor(gridContainer, width) {
//             this.gridContainer = gridContainer;
//             this.width = width;
//             this.svgContainer = null;
//         }

//         getGridItemCenter(index) {
//             if (index === undefined || index === null) {
//                 return null;
//             }

//             const gridItem = this.gridContainer.children[index];
//             if (!gridItem) {
//                 return null;
//             }

//             const containerRect = this.gridContainer.getBoundingClientRect();
//             const itemRect = gridItem.getBoundingClientRect();

//             return {
//                 x: itemRect.left - containerRect.left + itemRect.width / 2,
//                 y: itemRect.top - containerRect.top + itemRect.height / 2
//             };
//         }

//         createSVGContainer() {
//             const existingSvg = this.gridContainer.querySelector('svg.route-svg');
//             if (existingSvg) existingSvg.remove();

//             const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
//             svg.classList.add('route-svg');
//             svg.style.position = 'absolute';
//             svg.style.top = '0';
//             svg.style.left = '0';
//             svg.style.width = '100%';
//             svg.style.height = '100%';
//             svg.style.pointerEvents = 'none';
//             svg.style.zIndex = '45';

//             this.gridContainer.style.position = 'relative';
//             this.gridContainer.appendChild(svg);
//             this.svgContainer = svg;

//             return svg;
//         }

//         createArrowMarker(svg) {
//             const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
//             const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
//             linearGradient.setAttribute('id', 'blueGradient');
//             linearGradient.setAttribute('x1', '0%');
//             linearGradient.setAttribute('y1', '0%');
//             linearGradient.setAttribute('x2', '100%');
//             linearGradient.setAttribute('y2', '0%');

//             const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop1.setAttribute('offset', '0%');
//             stop1.setAttribute('stop-color', '#3498db');

//             const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop2.setAttribute('offset', '100%');
//             stop2.setAttribute('stop-color', '#2ecc71');

//             linearGradient.appendChild(stop1);
//             linearGradient.appendChild(stop2);

//             const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
//             marker.setAttribute('id', 'arrow');
//             marker.setAttribute('markerWidth', '10');
//             marker.setAttribute('markerHeight', '7');
//             marker.setAttribute('refX', '5');
//             marker.setAttribute('refY', '3.5');
//             marker.setAttribute('orient', 'auto');

//             const arrowhead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
//             arrowhead.setAttribute('points', '0 0, 10 3.5, 0 7');
//             arrowhead.setAttribute('fill', 'url(#blueGradient)');

//             marker.appendChild(arrowhead);
//             defs.appendChild(linearGradient);
//             defs.appendChild(marker);

//             svg.appendChild(defs);
//         }

//         drawRoutePath(start, end, svg) {
//             if (!start || !end) {
//                 return null;
//             }

//             const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
//             path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
//             path.setAttribute('stroke', 'url(#blueGradient)');
//             path.setAttribute('stroke-width', '4');
//             path.setAttribute('fill', 'none');
//             path.setAttribute('marker-end', 'url(#arrow)');

//             return path;
//         }

//         visualizeRoute(route) {
//             const svg = this.createSVGContainer();
//             this.createArrowMarker(svg);

//             route.forEach(index => {
//                 const gridItem = this.gridContainer.children[index];
//                 if (gridItem) {
//                     gridItem.classList.add('route-highlight');
//                 }
//             });

//             for (let i = 0; i < route.length - 1; i++) {
//                 const start = this.getGridItemCenter(route[i]);
//                 const end = this.getGridItemCenter(route[i + 1]);

//                 if (start && end) {
//                     const routePath = this.drawRoutePath(start, end, svg);
//                     if (routePath) {
//                         svg.appendChild(routePath);
//                     }
//                 }
//             }
//         }
//     }

//     // Add enhanced CSS for better visualization
//     const styleSheet = document.createElement('style');
//     styleSheet.textContent = `
//         .route-highlight {
//             background-color: rgba(52, 152, 219, 0.3) !important;
//             transition: background-color 0.3s ease;
//             box-shadow: inset 0 0 0 2px #3498db;
//         }
        
//         .optimal-path-info {
//             position: sticky;
//             top: 10px;
//             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
//             color: white;
//             padding: 10px;
//             border-radius: 8px;
//             margin-bottom: 10px;
//             font-size: 14px;
//             z-index: 0;
//         }
//     `;
//     document.head.appendChild(styleSheet);

//     // MAIN: Enhanced route finding implementation
//     findRouteBtn.addEventListener('click', function() {
//         // Get selected item IDs
//         const selectedItems = Array.from(
//             itemsSelect.selectedOptions
//         ).map(option => option.value);

//         // Validate item selection
//         if (selectedItems.length === 0) {
//             alert('Please select at least one item');
//             return;
//         }

//         // RESEARCH IMPLEMENTATION: Use enhanced navigator and pathfinder
//         const navigator = new EnhancedSupermarketNavigator(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }}
//         );

//         const pathFinder = new MultiObjectiveAStar(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }},
//             selectedItems  
//         );

//         // Find key locations
//         const entrance = navigator.findFirstCellOfMode('entrance');
//         const cart = navigator.findFirstCellOfMode('cart');
//         const exit = navigator.findFirstCellOfMode('exit');

//         // Find shelves with selected items
//         const itemShelves = navigator.findShelvesWithItems(selectedItems);

//         // Validate location finding
//         if (!entrance || !cart || !exit || itemShelves.length === 0) {
//             alert('Could not find all required locations or items');
//             return;
//         }

//         // NOVEL: Optimize shelf visit order
//         const optimizedShelves = navigator.optimizeShelfOrder(itemShelves, cart);

//         let currentLocation = entrance.index;
//         let fullRoute = [currentLocation];

//         // Route from entrance to cart using enhanced A*
//         const toCartPath = pathFinder.findOptimalPath(currentLocation, cart.index);
//         if (toCartPath && toCartPath.length > 1) {
//             fullRoute = fullRoute.concat(toCartPath.slice(1));
//             currentLocation = cart.index;
//         }

//         // Route to each shelf in optimized order using enhanced A*
//         for (const shelfLocation of optimizedShelves) {
//             const toShelfPath = pathFinder.findOptimalPath(currentLocation, shelfLocation.index);
//             if (toShelfPath && toShelfPath.length > 1) {
//                 fullRoute = fullRoute.concat(toShelfPath.slice(1));
//                 currentLocation = shelfLocation.index;
//             }
//         }

//         // Route to exit using enhanced A*
//         const toExitPath = pathFinder.findOptimalPath(currentLocation, exit.index);
//         if (toExitPath && toExitPath.length > 1) {
//             fullRoute = fullRoute.concat(toExitPath.slice(1));
//         }

//         // Display optimization info
//         const infoDiv = document.createElement('div');
//         infoDiv.className = 'optimal-path-info';
//         infoDiv.innerHTML = `
//             <strong>🎯 Enhanced Multi-Objective Route Generated</strong><br>
//             📊 Total Path Length: ${fullRoute.length} steps<br>
//             🛒 Optimized ${optimizedShelves.length} shelf visits<br>
//             ⚡ Using: Congestion avoidance + Accessibility optimization + Flow patterns
//         `;
        
//         // Remove existing info if present
//         const existingInfo = document.querySelector('.optimal-path-info');
//         if (existingInfo) existingInfo.remove();
        
//         gridContainer.parentNode.insertBefore(infoDiv, gridContainer);

//         // Visualize the enhanced route
//         const visualizer = new RouteVisualizer(gridContainer, {{ floor.width }});
//         visualizer.visualizeRoute(fullRoute);

//         // Log performance metrics for research
//         console.log('=== RESEARCH METRICS ===');
//         console.log('Algorithm: Multi-Objective A*');
//         console.log('Path length:', fullRoute.length);
//         console.log('Shelves optimized:', optimizedShelves.length);
//         console.log('Weights used:', pathFinder.weights);
//         console.log('========================');
//     });
    
// });



// 9
// Fixed Multi-Objective A* Algorithm with Proper Shelf Access
// document.addEventListener('DOMContentLoaded', function() {
//     const findRouteBtn = document.getElementById('findRoute');
//     const itemsSelect = document.getElementById('items_name');
//     const gridContainer = document.getElementById('grid-container');

//     class SupermarketNavigator {
//         constructor(floor, width, length) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//         }

//         findShelvesWithItems(selectedItemIds) {
//             const shelves = [];
//             const selectedItemStrings = selectedItemIds.map(id => id.toString());

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 if (cell.mode === 'shelf') {
//                     if (Array.isArray(cell.itemIds) && cell.itemIds.length > 0) {
//                         const cellItemStrings = cell.itemIds.map(id => id.toString());
//                         const matchedItems = cellItemStrings.filter(id => selectedItemStrings.includes(id));

//                         if (matchedItems.length > 0) {
//                             const row = Math.floor(index / this.width);
//                             const col = index % this.width;
//                             shelves.push({ index: parseInt(index), row, col, items: matchedItems });
//                         }
//                     }
//                 }
//             });

//             return shelves;
//         }

//         findFirstCellOfMode(mode) {
//             for (const [index, cell] of Object.entries(this.floor)) {
//                 if (cell.mode === mode) {
//                     const row = Math.floor(index / this.width);
//                     const col = index % this.width;
//                     return { index: parseInt(index), row, col };
//                 }
//             }
//             return null;
//         }

//         // NEW: Find accessible positions adjacent to target shelves
//         findAccessibleShelfPositions(shelves, pathFinder) {
//             const accessiblePositions = [];
            
//             shelves.forEach(shelf => {
//                 const shelfRow = Math.floor(shelf.index / this.width);
//                 const shelfCol = shelf.index % this.width;
                
//                 // Check all 4 adjacent positions (up, right, down, left)
//                 const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//                 for (const [dx, dy] of directions) {
//                     const adjRow = shelfRow + dx;
//                     const adjCol = shelfCol + dy;
//                     const adjIndex = adjRow * this.width + adjCol;
                    
//                     // Check if adjacent position is valid and passable
//                     if (pathFinder.isValidMove(adjRow, adjCol)) {
//                         accessiblePositions.push({
//                             index: adjIndex,
//                             row: adjRow,
//                             col: adjCol,
//                             targetShelf: shelf,
//                             items: shelf.items
//                         });
//                         break; // Take the first accessible position for this shelf
//                     }
//                 }
//             });
            
//             return accessiblePositions;
//         }
//     }

//     // Fixed Multi-Objective A* Algorithm
//     class MultiObjectiveAStar {
//         constructor(floor, width, length, selectedItemIds) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//             this.selectedItemIds = selectedItemIds.map(id => id.toString());
            
//             // Multi-objective optimization weights
//             this.weights = {
//                 distance: 1.0,
//                 congestion: 0.4,
//                 accessibility: 0.3,
//                 shoppingFlow: 0.2,
//                 turnPenalty: 0.15
//             };
            
//             this.grid = this.createEnhancedNavigationGrid();
//             this.congestionMatrix = this.initializeCongestionMatrix();
//             this.accessibilityMatrix = this.initializeAccessibilityMatrix();
//         }

//         // Enhanced grid creation with proper blocking
//         createEnhancedNavigationGrid() {
//             const grid = Array(this.length).fill(null).map(() => 
//                 Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
//             );

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;

//                 if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                     console.warn(`Invalid grid position: row=${row}, col=${col}`);
//                     return;
//                 }

//                 if (cell.mode === 'wall') {
//                     grid[row][col] = { passable: false, cost: Infinity };
//                 }
//                 else if (cell.mode === 'shelf') {
//                     // ALL shelves are impassable - you can't walk through them!
//                     grid[row][col] = { passable: false, cost: Infinity };
//                 }
//                 else if (cell.mode === 'checkout' || cell.mode === 'cart') {
//                     // These are special locations we can reach as destinations
//                     grid[row][col] = { passable: true, cost: 1.0 };
//                 }
//                 else if (cell.mode === 'entrance' || cell.mode === 'exit') {
//                     // Entrance and exit points are passable
//                     grid[row][col] = { passable: true, cost: 0.8 };
//                 }
//                 else {
//                     // Open space - apply congestion-based cost later
//                     const congestionLevel = this.getCongestionLevel(row, col);
//                     grid[row][col] = { 
//                         passable: true, 
//                         cost: 1.0 + (congestionLevel * 0.3) 
//                     };
//                 }
//             });

//             return grid;
//         }

//         // Multi-objective heuristic function
//         multiObjectiveHeuristic(current, goal, gScore, path) {
//             const [currentRow, currentCol] = current;
//             const [goalRow, goalCol] = goal;
            
//             const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
//             const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
//             const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
//             const flowBonus = this.getShoppingFlowBonus(current, goal);
//             const turnPenalty = this.calculateTurnPenalty(path, current);
            
//             const heuristic = 
//                 (this.weights.distance * manhattanDistance) +
//                 (this.weights.congestion * congestionPenalty) -
//                 (this.weights.accessibility * accessibilityBonus) -
//                 (this.weights.shoppingFlow * flowBonus) +
//                 (this.weights.turnPenalty * turnPenalty);
            
//             return Math.max(0, heuristic);
//         }

//         // Enhanced A* with multi-objective optimization
//         findOptimalPath(start, end) {
//             const startRow = Math.floor(start / this.width);
//             const startCol = start % this.width;
//             const endRow = Math.floor(end / this.width);
//             const endCol = end % this.width;

//             if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
//                 console.error('Invalid start or end position');
//                 return null;
//             }

//             const openList = [{
//                 position: [startRow, startCol],
//                 path: [start],
//                 gScore: 0,
//                 fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
//                 parent: null
//             }];
            
//             const closedList = new Set();
//             const bestGScores = new Map();

//             while (openList.length > 0) {
//                 openList.sort((a, b) => a.fScore - b.fScore);
//                 const current = openList.shift();
                
//                 const [row, col] = current.position;
//                 const positionKey = `${row},${col}`;

//                 if (closedList.has(positionKey)) continue;
//                 closedList.add(positionKey);

//                 if (row === endRow && col === endCol) {
//                     return current.path;
//                 }

//                 const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//                 for (const [dx, dy] of directions) {
//                     const newRow = row + dx;
//                     const newCol = col + dy;
//                     const newIndex = newRow * this.width + newCol;
//                     const newPositionKey = `${newRow},${newCol}`;

//                     if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
//                         continue;
//                     }

//                     const moveCost = this.calculateEnhancedMoveCost(
//                         [row, col], 
//                         [newRow, newCol], 
//                         current.path
//                     );

//                     const newGScore = current.gScore + moveCost;
//                     const newPath = [...current.path, newIndex];
                    
//                     const bestG = bestGScores.get(newPositionKey);
//                     if (bestG !== undefined && newGScore >= bestG) {
//                         continue;
//                     }
//                     bestGScores.set(newPositionKey, newGScore);

//                     const newFScore = newGScore + this.multiObjectiveHeuristic(
//                         [newRow, newCol], 
//                         [endRow, endCol], 
//                         newGScore,
//                         newPath
//                     );

//                     const existingIndex = openList.findIndex(node => 
//                         node.position[0] === newRow && node.position[1] === newCol
//                     );
                    
//                     if (existingIndex !== -1) {
//                         if (newGScore < openList[existingIndex].gScore) {
//                             openList.splice(existingIndex, 1);
//                         } else {
//                             continue;
//                         }
//                     }

//                     openList.push({
//                         position: [newRow, newCol],
//                         path: newPath,
//                         gScore: newGScore,
//                         fScore: newFScore,
//                         parent: current
//                     });
//                 }
//             }

//             return null;
//         }

//         calculateEnhancedMoveCost(from, to, currentPath) {
//             const [toRow, toCol] = to;
            
//             const gridCell = this.grid[toRow][toCol];
//             let baseCost = gridCell.cost;
            
//             const congestionLevel = this.getCongestionLevel(toRow, toCol);
//             const congestionMultiplier = 1 + (congestionLevel * 0.3);
//             const turnPenalty = this.getDirectionChangePenalty(currentPath, [toRow, toCol]);
//             const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
            
//             return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
//         }

//         isValidMove(row, col) {
//             if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
//                 return false;
//             }
            
//             if (!this.grid || !this.grid[row] || !this.grid[row][col]) {
//                 return false;
//             }
            
//             return this.grid[row][col].passable;
//         }

//         // Supporting methods (shortened for brevity - include all your existing methods)
//         initializeCongestionMatrix() {
//             const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
//             for (let i = 0; i < this.length; i++) {
//                 for (let j = 0; j < this.width; j++) {
//                     const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
//                     const maxDistance = (this.length + this.width) / 2;
//                     matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
//                     matrix[i][j] += Math.random() * 0.2;
//                 }
//             }
            
//             return matrix;
//         }

//         initializeAccessibilityMatrix() {
//             const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;
                
//                 if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                     return;
//                 }
                
//                 if (cell.mode === 'shelf' && cell.itemIds) {
//                     const hasRequiredItems = cell.itemIds.some(id => 
//                         this.selectedItemIds.includes(id.toString())
//                     );
                    
//                     if (hasRequiredItems) {
//                         let freeSpaces = 0;
//                         const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        
//                         for (const [dx, dy] of directions) {
//                             const checkRow = row + dx;
//                             const checkCol = col + dy;
//                             if (this.isValidPosition(checkRow, checkCol)) {
//                                 freeSpaces++;
//                             }
//                         }
                        
//                         matrix[row][col] = freeSpaces / 4.0;
//                     }
//                 }
//             });
            
//             return matrix;
//         }

//         isValidPosition(row, col) {
//             return row >= 0 && row < this.length && col >= 0 && col < this.width;
//         }

//         getCongestionLevel(row, col) {
//             if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
//                 return this.congestionMatrix[row][col];
//             }
//             return 0;
//         }

//         getAccessibilityBonus(row, col) {
//             if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
//                 return this.accessibilityMatrix[row][col];
//             }
//             return 0;
//         }

//         getShoppingFlowBonus(current, goal) {
//             const [currentRow, currentCol] = current;
//             const [goalRow, goalCol] = goal;
            
//             const currentPerimeterDistance = Math.min(
//                 currentRow, currentCol, 
//                 this.length - 1 - currentRow, 
//                 this.width - 1 - currentCol
//             );
            
//             const goalPerimeterDistance = Math.min(
//                 goalRow, goalCol, 
//                 this.length - 1 - goalRow, 
//                 this.width - 1 - goalCol
//             );
            
//             if (currentPerimeterDistance <= goalPerimeterDistance) {
//                 return 0.3;
//             }
            
//             return 0;
//         }

//         calculateTurnPenalty(path, current) {
//             if (path.length < 2) return 0;
            
//             const [currentRow, currentCol] = current;
//             const lastIndex = path[path.length - 1];
//             const secondLastIndex = path[path.length - 2];
            
//             const lastRow = Math.floor(lastIndex / this.width);
//             const lastCol = lastIndex % this.width;
//             const secondLastRow = Math.floor(secondLastIndex / this.width);
//             const secondLastCol = secondLastIndex % this.width;
            
//             const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//             const newDirection = [currentRow - lastRow, currentCol - lastCol];
            
//             if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//                 return 0.2;
//             }
            
//             return 0;
//         }

//         getDirectionChangePenalty(path, newPosition) {
//             if (path.length < 2) return 0;
            
//             const [newRow, newCol] = newPosition;
//             const lastIndex = path[path.length - 1];
//             const secondLastIndex = path[path.length - 2];
            
//             const lastRow = Math.floor(lastIndex / this.width);
//             const lastCol = lastIndex % this.width;
//             const secondLastRow = Math.floor(secondLastIndex / this.width);
//             const secondLastCol = secondLastIndex % this.width;
            
//             const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//             const newDirection = [newRow - lastRow, newCol - lastCol];
            
//             if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//                 return 0.15;
//             }
            
//             return 0;
//         }
//     }

//     // Enhanced Navigator with intelligent shelf ordering
//     class EnhancedSupermarketNavigator extends SupermarketNavigator {
//         constructor(floor, width, length) {
//             super(floor, width, length);
//         }

//         optimizeShelfOrder(shelves, startLocation) {
//             if (shelves.length <= 1) return shelves;
            
//             const points = [startLocation, ...shelves];
//             const distances = this.calculateDistanceMatrix(points);
            
//             const optimizedOrder = [];
//             let currentIndex = 0;
//             const unvisited = new Set(Array.from({length: shelves.length}, (_, i) => i + 1));
            
//             while (unvisited.size > 0) {
//                 let nearestIndex = -1;
//                 let nearestDistance = Infinity;
                
//                 for (const index of unvisited) {
//                     let distance = distances[currentIndex][index];
                    
//                     const flowBonus = this.calculateShoppingFlowBonus(
//                         points[currentIndex], 
//                         points[index]
//                     );
//                     distance -= flowBonus;
                    
//                     if (distance < nearestDistance) {
//                         nearestDistance = distance;
//                         nearestIndex = index;
//                     }
//                 }
                
//                 unvisited.delete(nearestIndex);
//                 optimizedOrder.push(shelves[nearestIndex - 1]);
//                 currentIndex = nearestIndex;
//             }
            
//             return optimizedOrder;
//         }

//         calculateDistanceMatrix(points) {
//             const matrix = Array(points.length).fill().map(() => Array(points.length).fill(0));
            
//             for (let i = 0; i < points.length; i++) {
//                 for (let j = 0; j < points.length; j++) {
//                     if (i !== j) {
//                         const point1 = points[i];
//                         const point2 = points[j];
//                         matrix[i][j] = Math.abs(point1.row - point2.row) + 
//                                       Math.abs(point1.col - point2.col);
//                     }
//                 }
//             }
            
//             return matrix;
//         }

//         calculateShoppingFlowBonus(point1, point2) {
//             if (point1.row <= point2.row && point1.col <= point2.col) {
//                 return 0.5;
//             }
//             return 0;
//         }
//     }

//     // RouteVisualizer class (unchanged)
//     class RouteVisualizer {
//         constructor(gridContainer, width) {
//             this.gridContainer = gridContainer;
//             this.width = width;
//             this.svgContainer = null;
//         }

//         getGridItemCenter(index) {
//             if (index === undefined || index === null) {
//                 return null;
//             }

//             const gridItem = this.gridContainer.children[index];
//             if (!gridItem) {
//                 return null;
//             }

//             const containerRect = this.gridContainer.getBoundingClientRect();
//             const itemRect = gridItem.getBoundingClientRect();

//             return {
//                 x: itemRect.left - containerRect.left + itemRect.width / 2,
//                 y: itemRect.top - containerRect.top + itemRect.height / 2
//             };
//         }

//         createSVGContainer() {
//             const existingSvg = this.gridContainer.querySelector('svg.route-svg');
//             if (existingSvg) existingSvg.remove();

//             const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
//             svg.classList.add('route-svg');
//             svg.style.position = 'absolute';
//             svg.style.top = '0';
//             svg.style.left = '0';
//             svg.style.width = '100%';
//             svg.style.height = '100%';
//             svg.style.pointerEvents = 'none';
//             svg.style.zIndex = '45';

//             this.gridContainer.style.position = 'relative';
//             this.gridContainer.appendChild(svg);
//             this.svgContainer = svg;

//             return svg;
//         }

//         createArrowMarker(svg) {
//             const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
//             const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
//             linearGradient.setAttribute('id', 'blueGradient');
//             linearGradient.setAttribute('x1', '0%');
//             linearGradient.setAttribute('y1', '0%');
//             linearGradient.setAttribute('x2', '100%');
//             linearGradient.setAttribute('y2', '0%');

//             const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop1.setAttribute('offset', '0%');
//             stop1.setAttribute('stop-color', '#3498db');

//             const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop2.setAttribute('offset', '100%');
//             stop2.setAttribute('stop-color', '#2ecc71');

//             linearGradient.appendChild(stop1);
//             linearGradient.appendChild(stop2);

//             const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
//             marker.setAttribute('id', 'arrow');
//             marker.setAttribute('markerWidth', '10');
//             marker.setAttribute('markerHeight', '7');
//             marker.setAttribute('refX', '5');
//             marker.setAttribute('refY', '3.5');
//             marker.setAttribute('orient', 'auto');

//             const arrowhead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
//             arrowhead.setAttribute('points', '0 0, 10 3.5, 0 7');
//             arrowhead.setAttribute('fill', 'url(#blueGradient)');

//             marker.appendChild(arrowhead);
//             defs.appendChild(linearGradient);
//             defs.appendChild(marker);

//             svg.appendChild(defs);
//         }

//         drawRoutePath(start, end, svg) {
//             if (!start || !end) {
//                 return null;
//             }

//             const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
//             path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
//             path.setAttribute('stroke', 'url(#blueGradient)');
//             path.setAttribute('stroke-width', '4');
//             path.setAttribute('fill', 'none');
//             path.setAttribute('marker-end', 'url(#arrow)');

//             return path;
//         }

//         visualizeRoute(route) {
//             const svg = this.createSVGContainer();
//             this.createArrowMarker(svg);

//             route.forEach(index => {
//                 const gridItem = this.gridContainer.children[index];
//                 if (gridItem) {
//                     gridItem.classList.add('route-highlight');
//                 }
//             });

//             for (let i = 0; i < route.length - 1; i++) {
//                 const start = this.getGridItemCenter(route[i]);
//                 const end = this.getGridItemCenter(route[i + 1]);

//                 if (start && end) {
//                     const routePath = this.drawRoutePath(start, end, svg);
//                     if (routePath) {
//                         svg.appendChild(routePath);
//                     }
//                 }
//             }
//         }
    
//     }

//     // Enhanced CSS
//     const styleSheet = document.createElement('style');
//     styleSheet.textContent = `
//         .route-highlight {
//             // background-color: rgba(52, 152, 219, 0.3) !important;
//             // transition: background-color 0.3s ease;
//             // box-shadow: inset 0 0 0 2px #3498db;
//         }
        
//         .optimal-path-info {
//             position: sticky;
//             top: 10px;
//             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
//             color: white;
//             padding: 10px;
//             border-radius: 8px;
//             margin-bottom: 10px;
//             font-size: 14px;
//             z-index: 0;
//         }
//     `;
//     document.head.appendChild(styleSheet);

//     // MAIN: Fixed route finding implementation
//     findRouteBtn.addEventListener('click', function() {
//         const selectedItems = Array.from(
//             itemsSelect.selectedOptions
//         ).map(option => option.value);

//         if (selectedItems.length === 0) {
//             alert('Please select at least one item');
//             return;
//         }

//         const navigator = new EnhancedSupermarketNavigator(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }}
//         );

//         const pathFinder = new MultiObjectiveAStar(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }},
//             selectedItems  
//         );

//         // Find key locations
//         const entrance = navigator.findFirstCellOfMode('entrance');
//         const cart = navigator.findFirstCellOfMode('cart');
//         const exit = navigator.findFirstCellOfMode('exit');

//         // Find shelves with selected items
//         const itemShelves = navigator.findShelvesWithItems(selectedItems);

//         if (!entrance || !cart || !exit || itemShelves.length === 0) {
//             alert('Could not find all required locations or items');
//             return;
//         }

//         // CRITICAL FIX: Find accessible positions adjacent to shelves
//         const accessibleShelfPositions = navigator.findAccessibleShelfPositions(itemShelves, pathFinder);

//         if (accessibleShelfPositions.length === 0) {
//             alert('Could not find accessible positions near the required items');
//             return;
//         }

//         console.log('Original shelves:', itemShelves);
//         console.log('Accessible positions:', accessibleShelfPositions);

//         // Optimize the order of accessible shelf positions
//         const optimizedPositions = navigator.optimizeShelfOrder(accessibleShelfPositions, cart);

        

//         // let currentLocation = entrance.index;
//         currentLocation = cart.index;
//         let fullRoute = [currentLocation];

//         // Route from entrance to cart
//         // const toCartPath = pathFinder.findOptimalPath(currentLocation, cart.index);
//         // if (toCartPath && toCartPath.length > 1) {
//         //     fullRoute = fullRoute.concat(toCartPath.slice(1));
//         //     currentLocation = cart.index;
//         // }
        

//         // Route to each accessible shelf position in optimized order
//         for (const shelfPosition of optimizedPositions) {
//             const toShelfPath = pathFinder.findOptimalPath(currentLocation, shelfPosition.index);
//             if (toShelfPath && toShelfPath.length > 1) {
//                 fullRoute = fullRoute.concat(toShelfPath.slice(1));
//                 currentLocation = shelfPosition.index;
//                 console.log(`Routed to accessible position ${shelfPosition.index} for shelf ${shelfPosition.targetShelf.index}`);
//             }
//         }

//         // Route to exit
//         const toExitPath = pathFinder.findOptimalPath(currentLocation, exit.index);
//         if (toExitPath && toExitPath.length > 1) {
//             fullRoute = fullRoute.concat(toExitPath.slice(1));
//         }

//         // Display optimization info
//         const infoDiv = document.createElement('div');
//         infoDiv.className = 'optimal-path-info';
//         infoDiv.innerHTML = `
//             <strong>🎯 Enhanced Multi-Objective Route Generated</strong><br>
//             📊 Total Path Length: ${fullRoute.length} steps<br>
//             🛒 Visiting ${optimizedPositions.length} item locations<br>
//             ⚡ Using: Shelf accessibility + Congestion avoidance + Flow optimization
//         `;
        
//         const existingInfo = document.querySelector('.optimal-path-info');
//         if (existingInfo) existingInfo.remove();
        
//         gridContainer.parentNode.insertBefore(infoDiv, gridContainer);
        

//         // Visualize the enhanced route
//         const visualizer = new RouteVisualizer(gridContainer, {{ floor.width }});
//         visualizer.visualizeRoute(fullRoute);

//         console.log('=== RESEARCH METRICS ===');
//         console.log('Algorithm: Multi-Objective A* with Shelf Accessibility');
//         console.log('Path length:', fullRoute.length);
//         console.log('Accessible positions found:', accessibleShelfPositions.length);
//         console.log('Route includes item pickup locations:', optimizedPositions.map(p => p.index));
//         console.log('========================');
//     });
// });



// 10 - Multi objective A*
document.addEventListener('DOMContentLoaded', function() {
    const findRouteBtn = document.getElementById('findRoute');
    const itemsSelect = document.getElementById('items_name');
    const gridContainer = document.getElementById('grid-container');

    class SupermarketNavigator {
        constructor(floor, width, length) {
            this.floor = floor;
            this.width = width;
            this.length = length;
        }

        findShelvesWithItems(selectedItemIds) {
            const shelves = [];
            const selectedItemStrings = selectedItemIds.map(id => id.toString());

            Object.entries(this.floor).forEach(([index, cell]) => {
                if (cell.mode === 'shelf') {
                    if (Array.isArray(cell.itemIds) && cell.itemIds.length > 0) {
                        const cellItemStrings = cell.itemIds.map(id => id.toString());
                        const matchedItems = cellItemStrings.filter(id => selectedItemStrings.includes(id));

                        if (matchedItems.length > 0) {
                            const row = Math.floor(index / this.width);
                            const col = index % this.width;
                            shelves.push({ index: parseInt(index), row, col, items: matchedItems });
                        }
                    }
                }
            });

            return shelves;
        }

        findFirstCellOfMode(mode) {
            for (const [index, cell] of Object.entries(this.floor)) {
                if (cell.mode === mode) {
                    const row = Math.floor(index / this.width);
                    const col = index % this.width;
                    return { index: parseInt(index), row, col };
                }
            }
            return null;
        }

        // NEW: Find accessible positions adjacent to target shelves
        findAccessibleShelfPositions(shelves, pathFinder) {
            const accessiblePositions = [];
            
            shelves.forEach(shelf => {
                const shelfRow = Math.floor(shelf.index / this.width);
                const shelfCol = shelf.index % this.width;
                
                // Check all 4 adjacent positions (up, right, down, left)
                const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
                for (const [dx, dy] of directions) {
                    const adjRow = shelfRow + dx;
                    const adjCol = shelfCol + dy;
                    const adjIndex = adjRow * this.width + adjCol;
                    
                    // Check if adjacent position is valid and passable
                    if (pathFinder.isValidMove(adjRow, adjCol)) {
                        accessiblePositions.push({
                            index: adjIndex,
                            row: adjRow,
                            col: adjCol,
                            targetShelf: shelf,
                            items: shelf.items
                        });
                        break; // Take the first accessible position for this shelf
                    }
                }
            });
            
            return accessiblePositions;
        }
    }

    // Fixed Multi-Objective A* Algorithm
    class MultiObjectiveAStar {
        constructor(floor, width, length, selectedItemIds) {
            this.floor = floor;
            this.width = width;
            this.length = length;
            this.selectedItemIds = selectedItemIds.map(id => id.toString());
            
            // Multi-objective optimization weights
            this.weights = {
                distance: 1.0,
                congestion: 0.4,
                accessibility: 0.3,
                shoppingFlow: 0.2,
                turnPenalty: 0.15
            };
            
            this.grid = this.createEnhancedNavigationGrid();
            this.congestionMatrix = this.initializeCongestionMatrix();
            this.accessibilityMatrix = this.initializeAccessibilityMatrix();
        }

        // Enhanced grid creation with proper blocking
        createEnhancedNavigationGrid() {
            const grid = Array(this.length).fill(null).map(() => 
                Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
            );

            Object.entries(this.floor).forEach(([index, cell]) => {
                const row = Math.floor(index / this.width);
                const col = index % this.width;

                if (row >= this.length || col >= this.width || row < 0 || col < 0) {
                    console.warn(`Invalid grid position: row=${row}, col=${col}`);
                    return;
                }

                if (cell.mode === 'wall') {
                    grid[row][col] = { passable: false, cost: Infinity };
                }
                else if (cell.mode === 'shelf') {
                    // ALL shelves are impassable - you can't walk through them!
                    grid[row][col] = { passable: false, cost: Infinity };
                }
                else if (cell.mode === 'checkout' || cell.mode === 'cart') {
                    // These are special locations we can reach as destinations
                    grid[row][col] = { passable: true, cost: 1.0 };
                }
                else if (cell.mode === 'entrance' || cell.mode === 'exit') {
                    // Entrance and exit points are passable
                    grid[row][col] = { passable: true, cost: 0.8 };
                }
                else {
                    // Open space - apply congestion-based cost later
                    const congestionLevel = this.getCongestionLevel(row, col);
                    grid[row][col] = { 
                        passable: true, 
                        cost: 1.0 + (congestionLevel * 0.3) 
                    };
                }
            });

            return grid;
        }

        // Multi-objective heuristic function
        multiObjectiveHeuristic(current, goal, gScore, path) {
            const [currentRow, currentCol] = current;
            const [goalRow, goalCol] = goal;
            
            const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
            const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
            const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
            const flowBonus = this.getShoppingFlowBonus(current, goal);
            const turnPenalty = this.calculateTurnPenalty(path, current);
            
            const heuristic = 
                (this.weights.distance * manhattanDistance) +
                (this.weights.congestion * congestionPenalty) -
                (this.weights.accessibility * accessibilityBonus) -
                (this.weights.shoppingFlow * flowBonus) +
                (this.weights.turnPenalty * turnPenalty);
            
            return Math.max(0, heuristic);
        }

        // Enhanced A* with multi-objective optimization
        findOptimalPath(start, end) {
            const startRow = Math.floor(start / this.width);
            const startCol = start % this.width;
            const endRow = Math.floor(end / this.width);
            const endCol = end % this.width;

            if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
                console.error('Invalid start or end position');
                return null;
            }

            const openList = [{
                position: [startRow, startCol],
                path: [start],
                gScore: 0,
                fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
                parent: null
            }];
            
            const closedList = new Set();
            const bestGScores = new Map();

            while (openList.length > 0) {
                openList.sort((a, b) => a.fScore - b.fScore);
                const current = openList.shift();
                
                const [row, col] = current.position;
                const positionKey = `${row},${col}`;

                if (closedList.has(positionKey)) continue;
                closedList.add(positionKey);

                if (row === endRow && col === endCol) {
                    return current.path;
                }

                const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    const newIndex = newRow * this.width + newCol;
                    const newPositionKey = `${newRow},${newCol}`;

                    if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
                        continue;
                    }

                    const moveCost = this.calculateEnhancedMoveCost(
                        [row, col], 
                        [newRow, newCol], 
                        current.path
                    );

                    const newGScore = current.gScore + moveCost;
                    const newPath = [...current.path, newIndex];
                    
                    const bestG = bestGScores.get(newPositionKey);
                    if (bestG !== undefined && newGScore >= bestG) {
                        continue;
                    }
                    bestGScores.set(newPositionKey, newGScore);

                    const newFScore = newGScore + this.multiObjectiveHeuristic(
                        [newRow, newCol], 
                        [endRow, endCol], 
                        newGScore,
                        newPath
                    );

                    const existingIndex = openList.findIndex(node => 
                        node.position[0] === newRow && node.position[1] === newCol
                    );
                    
                    if (existingIndex !== -1) {
                        if (newGScore < openList[existingIndex].gScore) {
                            openList.splice(existingIndex, 1);
                        } else {
                            continue;
                        }
                    }

                    openList.push({
                        position: [newRow, newCol],
                        path: newPath,
                        gScore: newGScore,
                        fScore: newFScore,
                        parent: current
                    });
                }
            }

            return null;
        }

        calculateEnhancedMoveCost(from, to, currentPath) {
            const [toRow, toCol] = to;
            
            const gridCell = this.grid[toRow][toCol];
            let baseCost = gridCell.cost;
            
            const congestionLevel = this.getCongestionLevel(toRow, toCol);
            const congestionMultiplier = 1 + (congestionLevel * 0.3);
            const turnPenalty = this.getDirectionChangePenalty(currentPath, [toRow, toCol]);
            const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
            
            return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
        }

        isValidMove(row, col) {
            if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
                return false;
            }
            
            if (!this.grid || !this.grid[row] || !this.grid[row][col]) {
                return false;
            }
            
            return this.grid[row][col].passable;
        }

        // Supporting methods (shortened for brevity - include all your existing methods)
        initializeCongestionMatrix() {
            const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
            for (let i = 0; i < this.length; i++) {
                for (let j = 0; j < this.width; j++) {
                    const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
                    const maxDistance = (this.length + this.width) / 2;
                    matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
                    matrix[i][j] += Math.random() * 0.2;
                }
            }
            
            return matrix;
        }

        initializeAccessibilityMatrix() {
            const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
            Object.entries(this.floor).forEach(([index, cell]) => {
                const row = Math.floor(index / this.width);
                const col = index % this.width;
                
                if (row >= this.length || col >= this.width || row < 0 || col < 0) {
                    return;
                }
                
                if (cell.mode === 'shelf' && cell.itemIds) {
                    const hasRequiredItems = cell.itemIds.some(id => 
                        this.selectedItemIds.includes(id.toString())
                    );
                    
                    if (hasRequiredItems) {
                        let freeSpaces = 0;
                        const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        
                        for (const [dx, dy] of directions) {
                            const checkRow = row + dx;
                            const checkCol = col + dy;
                            if (this.isValidPosition(checkRow, checkCol)) {
                                freeSpaces++;
                            }
                        }
                        
                        matrix[row][col] = freeSpaces / 4.0;
                    }
                }
            });
            
            return matrix;
        }

        isValidPosition(row, col) {
            return row >= 0 && row < this.length && col >= 0 && col < this.width;
        }

        getCongestionLevel(row, col) {
            if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
                return this.congestionMatrix[row][col];
            }
            return 0;
        }

        getAccessibilityBonus(row, col) {
            if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
                return this.accessibilityMatrix[row][col];
            }
            return 0;
        }

        getShoppingFlowBonus(current, goal) {
            const [currentRow, currentCol] = current;
            const [goalRow, goalCol] = goal;
            
            const currentPerimeterDistance = Math.min(
                currentRow, currentCol, 
                this.length - 1 - currentRow, 
                this.width - 1 - currentCol
            );
            
            const goalPerimeterDistance = Math.min(
                goalRow, goalCol, 
                this.length - 1 - goalRow, 
                this.width - 1 - goalCol
            );
            
            if (currentPerimeterDistance <= goalPerimeterDistance) {
                return 0.3;
            }
            
            return 0;
        }

        calculateTurnPenalty(path, current) {
            if (path.length < 2) return 0;
            
            const [currentRow, currentCol] = current;
            const lastIndex = path[path.length - 1];
            const secondLastIndex = path[path.length - 2];
            
            const lastRow = Math.floor(lastIndex / this.width);
            const lastCol = lastIndex % this.width;
            const secondLastRow = Math.floor(secondLastIndex / this.width);
            const secondLastCol = secondLastIndex % this.width;
            
            const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
            const newDirection = [currentRow - lastRow, currentCol - lastCol];
            
            if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
                return 0.2;
            }
            
            return 0;
        }

        getDirectionChangePenalty(path, newPosition) {
            if (path.length < 2) return 0;
            
            const [newRow, newCol] = newPosition;
            const lastIndex = path[path.length - 1];
            const secondLastIndex = path[path.length - 2];
            
            const lastRow = Math.floor(lastIndex / this.width);
            const lastCol = lastIndex % this.width;
            const secondLastRow = Math.floor(secondLastIndex / this.width);
            const secondLastCol = secondLastIndex % this.width;
            
            const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
            const newDirection = [newRow - lastRow, newCol - lastCol];
            
            if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
                return 0.15;
            }
            
            return 0;
        }
    }

    // Enhanced Navigator with intelligent shelf ordering
    class EnhancedSupermarketNavigator extends SupermarketNavigator {
        constructor(floor, width, length) {
            super(floor, width, length);
        }

        optimizeShelfOrder(shelves, startLocation) {
            if (shelves.length <= 1) return shelves;
            
            const points = [startLocation, ...shelves];
            const distances = this.calculateDistanceMatrix(points);
            
            const optimizedOrder = [];
            let currentIndex = 0;
            const unvisited = new Set(Array.from({length: shelves.length}, (_, i) => i + 1));
            
            while (unvisited.size > 0) {
                let nearestIndex = -1;
                let nearestDistance = Infinity;
                
                for (const index of unvisited) {
                    let distance = distances[currentIndex][index];
                    
                    const flowBonus = this.calculateShoppingFlowBonus(
                        points[currentIndex], 
                        points[index]
                    );
                    distance -= flowBonus;
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestIndex = index;
                    }
                }
                
                unvisited.delete(nearestIndex);
                optimizedOrder.push(shelves[nearestIndex - 1]);
                currentIndex = nearestIndex;
            }
            
            return optimizedOrder;
        }

        calculateDistanceMatrix(points) {
            const matrix = Array(points.length).fill().map(() => Array(points.length).fill(0));
            
            for (let i = 0; i < points.length; i++) {
                for (let j = 0; j < points.length; j++) {
                    if (i !== j) {
                        const point1 = points[i];
                        const point2 = points[j];
                        matrix[i][j] = Math.abs(point1.row - point2.row) + 
                                      Math.abs(point1.col - point2.col);
                    }
                }
            }
            
            return matrix;
        }

        calculateShoppingFlowBonus(point1, point2) {
            if (point1.row <= point2.row && point1.col <= point2.col) {
                return 0.5;
            }
            return 0;
        }
    }

    // Enhanced RouteVisualizer class with numbered shelf markers
    class RouteVisualizer {
        constructor(gridContainer, width) {
            this.gridContainer = gridContainer;
            this.width = width;
            this.svgContainer = null;
        }

        getGridItemCenter(index) {
            if (index === undefined || index === null) {
                return null;
            }

            const gridItem = this.gridContainer.children[index];
            if (!gridItem) {
                return null;
            }

            const containerRect = this.gridContainer.getBoundingClientRect();
            const itemRect = gridItem.getBoundingClientRect();

            return {
                x: itemRect.left - containerRect.left + itemRect.width / 2,
                y: itemRect.top - containerRect.top + itemRect.height / 2
            };
        }

        createSVGContainer() {
            const existingSvg = this.gridContainer.querySelector('svg.route-svg');
            if (existingSvg) existingSvg.remove();

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add('route-svg');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '45';

            this.gridContainer.style.position = 'relative';
            this.gridContainer.appendChild(svg);
            this.svgContainer = svg;

            return svg;
        }

        createArrowMarker(svg) {
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            linearGradient.setAttribute('id', 'blueGradient');
            linearGradient.setAttribute('x1', '0%');
            linearGradient.setAttribute('y1', '0%');
            linearGradient.setAttribute('x2', '100%');
            linearGradient.setAttribute('y2', '0%');

            const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#3498db');

            const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#2ecc71');

            linearGradient.appendChild(stop1);
            linearGradient.appendChild(stop2);

            const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.setAttribute('id', 'arrow');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');

            const arrowhead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            arrowhead.setAttribute('points', '0 0, 10 3.5, 0 7');
            arrowhead.setAttribute('fill', 'url(#blueGradient)');

            marker.appendChild(arrowhead);
            defs.appendChild(linearGradient);
            defs.appendChild(marker);

            svg.appendChild(defs);
        }

        drawRoutePath(start, end, svg) {
            if (!start || !end) {
                return null;
            }

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
            path.setAttribute('stroke', 'url(#blueGradient)');
            path.setAttribute('stroke-width', '4');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrow)');

            return path;
        }

        // NEW: Create numbered markers for shelves
        createShelfMarker(svg, position, number, items) {
            const center = this.getGridItemCenter(position);
            if (!center) return null;

            // Create marker group
            const markerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            markerGroup.setAttribute('class', 'shelf-marker');

            // Create circle background
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute('cx', center.x);
            circle.setAttribute('cy', center.y);
            circle.setAttribute('r', '18');
            circle.setAttribute('fill', '#e74c3c');
            circle.setAttribute('stroke', '#ffffff');
            circle.setAttribute('stroke-width', '3');
            circle.setAttribute('opacity', '0.9');

            // Create number text
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute('x', center.x);
            text.setAttribute('y', center.y + 6);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', '#ffffff');
            text.setAttribute('font-family', 'Arial, sans-serif');
            text.setAttribute('font-size', '16');
            text.setAttribute('font-weight', 'bold');
            text.textContent = number;

            // Create tooltip title for hover effect
            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.textContent = `Stop ${number}: Items - ${items.join(', ')}`;

            markerGroup.appendChild(circle);
            markerGroup.appendChild(text);
            markerGroup.appendChild(title);

            return markerGroup;
        }

        // NEW: Clear existing markers
        clearShelfMarkers() {
            const existingMarkers = this.gridContainer.querySelectorAll('.shelf-marker-overlay');
            existingMarkers.forEach(marker => marker.remove());
        }

        // Enhanced visualizeRoute method with shelf markers
        visualizeRoute(route, optimizedPositions = []) {
            const svg = this.createSVGContainer();
            this.createArrowMarker(svg);

            // Clear existing markers
            this.clearShelfMarkers();

            // Highlight route path
            route.forEach(index => {
                const gridItem = this.gridContainer.children[index];
                if (gridItem) {
                    gridItem.classList.add('route-highlight');
                }
            });

            // Draw route lines
            for (let i = 0; i < route.length - 1; i++) {
                const start = this.getGridItemCenter(route[i]);
                const end = this.getGridItemCenter(route[i + 1]);

                if (start && end) {
                    const routePath = this.drawRoutePath(start, end, svg);
                    if (routePath) {
                        svg.appendChild(routePath);
                    }
                }
            }

            // Add numbered markers for shelf positions
            optimizedPositions.forEach((position, index) => {
                const marker = this.createShelfMarker(
                    svg, 
                    position.targetShelf.index, 
                    index + 1, 
                    position.items
                );
                if (marker) {
                    svg.appendChild(marker);
                }
            });
        }
    }

    // Enhanced CSS
    const styleSheet = document.createElement('style');
    styleSheet.textContent = `
        .route-highlight {
            // background-color: rgba(52, 152, 219, 0.3) !important;
            // transition: background-color 0.3s ease;
            // box-shadow: inset 0 0 0 2px #3498db;
        }
        
        .shelf-marker {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .shelf-marker:hover {
            transform: scale(1.1);
        }
        
        .shelf-marker circle {
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }
        
        .optimal-path-info {
            position: sticky;
            top: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 14px;
            z-index: 0;
        }
        
        .shelf-info {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 8px;
            border-radius: 6px;
            margin-top: 5px;
            font-size: 12px;
        }
    `;
    document.head.appendChild(styleSheet);

    // MAIN: Enhanced route finding implementation with markers
    findRouteBtn.addEventListener('click', function() {
        const selectedItems = Array.from(
            itemsSelect.selectedOptions
        ).map(option => option.value);

        if (selectedItems.length === 0) {
            alert('Please select at least one item');
            return;
        }

        const navigator = new EnhancedSupermarketNavigator(
            {{ floor_data_json|safe }}, 
            {{ floor.width }}, 
            {{ floor.length }}
        );

        const pathFinder = new MultiObjectiveAStar(
            {{ floor_data_json|safe }}, 
            {{ floor.width }}, 
            {{ floor.length }},
            selectedItems  
        );

        // Find key locations
        const entrance = navigator.findFirstCellOfMode('entrance');
        const cart = navigator.findFirstCellOfMode('cart');
        const exit = navigator.findFirstCellOfMode('exit');

        // Find shelves with selected items
        const itemShelves = navigator.findShelvesWithItems(selectedItems);

        if (!entrance || !cart || !exit || itemShelves.length === 0) {
            alert('Could not find all required locations or items');
            return;
        }

        // CRITICAL FIX: Find accessible positions adjacent to shelves
        const accessibleShelfPositions = navigator.findAccessibleShelfPositions(itemShelves, pathFinder);

        if (accessibleShelfPositions.length === 0) {
            alert('Could not find accessible positions near the required items');
            return;
        }

        console.log('Original shelves:', itemShelves);
        console.log('Accessible positions:', accessibleShelfPositions);

        // Optimize the order of accessible shelf positions
        const optimizedPositions = navigator.optimizeShelfOrder(accessibleShelfPositions, cart);

        let currentLocation = cart.index;
        let fullRoute = [currentLocation];

        // Route to each accessible shelf position in optimized order
        for (const shelfPosition of optimizedPositions) {
            const toShelfPath = pathFinder.findOptimalPath(currentLocation, shelfPosition.index);
            if (toShelfPath && toShelfPath.length > 1) {
                fullRoute = fullRoute.concat(toShelfPath.slice(1));
                currentLocation = shelfPosition.index;
                console.log(`Routed to accessible position ${shelfPosition.index} for shelf ${shelfPosition.targetShelf.index}`);
            }
        }

        // Route to exit
        const toExitPath = pathFinder.findOptimalPath(currentLocation, exit.index);
        if (toExitPath && toExitPath.length > 1) {
            fullRoute = fullRoute.concat(toExitPath.slice(1));
        }

        // Display optimization info with shelf details
        const shelfDetails = optimizedPositions.map((pos, index) => 
            `${index + 1}. Items: ${pos.items.join(', ')}`
        ).join('<br>');

        const infoDiv = document.createElement('div');
        infoDiv.className = 'optimal-path-info';
        infoDiv.innerHTML = `
            <strong>🎯 Enhanced Multi-Objective Route Generated</strong><br>
            📊 Total Path Length: ${fullRoute.length} steps<br>
            🛒 Visiting ${optimizedPositions.length} item locations<br>
            ⚡ Using: Shelf accessibility + Congestion avoidance + Flow optimization
            <div class="shelf-info">
                <strong>📍 Numbered Shelf Stops:</strong><br>
                ${shelfDetails}
            </div>
        `;
        
        const existingInfo = document.querySelector('.optimal-path-info');
        if (existingInfo) existingInfo.remove();
        
        // Uncomment the line below if you want to show the info panel
        // gridContainer.parentNode.insertBefore(infoDiv, gridContainer);

        // Visualize the enhanced route with numbered shelf markers
        const visualizer = new RouteVisualizer(gridContainer, {{ floor.width }});
        visualizer.visualizeRoute(fullRoute, optimizedPositions);

        console.log('=== RESEARCH METRICS ===');
        console.log('Algorithm: Multi-Objective A* with Shelf Accessibility');
        console.log('Path length:', fullRoute.length);
        console.log('Accessible positions found:', accessibleShelfPositions.length);
        console.log('Route includes item pickup locations:', optimizedPositions.map(p => p.index));
        console.log('Shelf markers created for:', optimizedPositions.map((p, i) => `${i+1}: Items ${p.items.join(',')}`));
        console.log('========================');
    });
});


// // 11
//    // Algorithm Comparison System - Multi objective A* and Standard A*
//     document.addEventListener('DOMContentLoaded', function() {
//     const findRouteBtn = document.getElementById('findRoute');
//     const itemsSelect = document.getElementById('items_name');
//     const gridContainer = document.getElementById('grid-container');

//     class SupermarketNavigator {
//         constructor(floor, width, length) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//         }

//         findShelvesWithItems(selectedItemIds) {
//             const shelves = [];
//             const selectedItemStrings = selectedItemIds.map(id => id.toString());

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 if (cell.mode === 'shelf') {
//                     if (Array.isArray(cell.itemIds) && cell.itemIds.length > 0) {
//                         const cellItemStrings = cell.itemIds.map(id => id.toString());
//                         const matchedItems = cellItemStrings.filter(id => selectedItemStrings.includes(id));

//                         if (matchedItems.length > 0) {
//                             const row = Math.floor(index / this.width);
//                             const col = index % this.width;
//                             shelves.push({ index: parseInt(index), row, col, items: matchedItems });
//                         }
//                     }
//                 }
//             });

//             return shelves;
//         }

//         findFirstCellOfMode(mode) {
//             for (const [index, cell] of Object.entries(this.floor)) {
//                 if (cell.mode === mode) {
//                     const row = Math.floor(index / this.width);
//                     const col = index % this.width;
//                     return { index: parseInt(index), row, col };
//                 }
//             }
//             return null;
//         }

//         // NEW: Find accessible positions adjacent to target shelves
//         findAccessibleShelfPositions(shelves, pathFinder) {
//             const accessiblePositions = [];
            
//             shelves.forEach(shelf => {
//                 const shelfRow = Math.floor(shelf.index / this.width);
//                 const shelfCol = shelf.index % this.width;
                
//                 // Check all 4 adjacent positions (up, right, down, left)
//                 const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//                 for (const [dx, dy] of directions) {
//                     const adjRow = shelfRow + dx;
//                     const adjCol = shelfCol + dy;
//                     const adjIndex = adjRow * this.width + adjCol;
                    
//                     // Check if adjacent position is valid and passable
//                     if (pathFinder.isValidMove(adjRow, adjCol)) {
//                         accessiblePositions.push({
//                             index: adjIndex,
//                             row: adjRow,
//                             col: adjCol,
//                             targetShelf: shelf,
//                             items: shelf.items
//                         });
//                         break; // Take the first accessible position for this shelf
//                     }
//                 }
//             });
            
//             return accessiblePositions;
//         }
//     }

//     // Traditional Standard A* Algorithm for comparison
//     class StandardAStar {
//         constructor(floor, width, length) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//             this.grid = this.createBasicNavigationGrid();
//             this.metrics = {
//                 pathLength: 0,
//                 turnCount: 0,
//                 computationTime: 0,
//                 nodesExplored: 0,
//                 congestionEncountered: 0
//             };
//         }

//         createBasicNavigationGrid() {
//             const grid = Array(this.length).fill(null).map(() => 
//                 Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
//             );

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;

//                 if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                     return;
//                 }

//                 if (cell.mode === 'wall' || cell.mode === 'shelf') {
//                     grid[row][col] = { passable: false, cost: Infinity };
//                 } else {
//                     grid[row][col] = { passable: true, cost: 1.0 };
//                 }
//             });

//             return grid;
//         }

//         manhattanDistance(current, goal) {
//             const [currentRow, currentCol] = current;
//             const [goalRow, goalCol] = goal;
//             return Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
//         }

//         findOptimalPath(start, end) {
//             const startTime = performance.now();
//             this.metrics.nodesExplored = 0;
//             this.metrics.congestionEncountered = 0;

//             const startRow = Math.floor(start / this.width);
//             const startCol = start % this.width;
//             const endRow = Math.floor(end / this.width);
//             const endCol = end % this.width;

//             if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
//                 return null;
//             }

//             const openList = [{
//                 position: [startRow, startCol],
//                 path: [start],
//                 gScore: 0,
//                 fScore: this.manhattanDistance([startRow, startCol], [endRow, endCol]),
//                 parent: null
//             }];
            
//             const closedList = new Set();
//             const bestGScores = new Map();

//             while (openList.length > 0) {
//                 openList.sort((a, b) => a.fScore - b.fScore);
//                 const current = openList.shift();
//                 this.metrics.nodesExplored++;
                
//                 const [row, col] = current.position;
//                 const positionKey = `${row},${col}`;

//                 if (closedList.has(positionKey)) continue;
//                 closedList.add(positionKey);

//                 if (row === endRow && col === endCol) {
//                     const endTime = performance.now();
//                     this.metrics.computationTime = endTime - startTime;
//                     this.metrics.pathLength = current.path.length;
//                     this.metrics.turnCount = this.calculateTurns(current.path);
//                     return current.path;
//                 }

//                 const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//                 for (const [dx, dy] of directions) {
//                     const newRow = row + dx;
//                     const newCol = col + dy;
//                     const newIndex = newRow * this.width + newCol;
//                     const newPositionKey = `${newRow},${newCol}`;

//                     if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
//                         continue;
//                     }

//                     // Check for congestion (simplified)
//                     if (this.isCongestionArea(newRow, newCol)) {
//                         this.metrics.congestionEncountered++;
//                     }

//                     const newGScore = current.gScore + 1;
//                     const newPath = [...current.path, newIndex];
                    
//                     const bestG = bestGScores.get(newPositionKey);
//                     if (bestG !== undefined && newGScore >= bestG) {
//                         continue;
//                     }
//                     bestGScores.set(newPositionKey, newGScore);

//                     const newFScore = newGScore + this.manhattanDistance([newRow, newCol], [endRow, endCol]);

//                     const existingIndex = openList.findIndex(node => 
//                         node.position[0] === newRow && node.position[1] === newCol
//                     );
                    
//                     if (existingIndex !== -1) {
//                         if (newGScore < openList[existingIndex].gScore) {
//                             openList.splice(existingIndex, 1);
//                         } else {
//                             continue;
//                         }
//                     }

//                     openList.push({
//                         position: [newRow, newCol],
//                         path: newPath,
//                         gScore: newGScore,
//                         fScore: newFScore,
//                         parent: current
//                     });
//                 }
//             }

//             const endTime = performance.now();
//             this.metrics.computationTime = endTime - startTime;
//             return null;
//         }

//         calculateTurns(path) {
//             if (path.length < 3) return 0;
            
//             let turns = 0;
//             for (let i = 2; i < path.length; i++) {
//                 const prev = path[i - 2];
//                 const curr = path[i - 1];
//                 const next = path[i];
                
//                 const prevRow = Math.floor(prev / this.width);
//                 const prevCol = prev % this.width;
//                 const currRow = Math.floor(curr / this.width);
//                 const currCol = curr % this.width;
//                 const nextRow = Math.floor(next / this.width);
//                 const nextCol = next % this.width;
                
//                 const dir1 = [currRow - prevRow, currCol - prevCol];
//                 const dir2 = [nextRow - currRow, nextCol - currCol];
                
//                 if (dir1[0] !== dir2[0] || dir1[1] !== dir2[1]) {
//                     turns++;
//                 }
//             }
//             return turns;
//         }

//         isCongestionArea(row, col) {
//             // Simple congestion detection - center areas are more congested
//             const centerRow = this.length / 2;
//             const centerCol = this.width / 2;
//             const distance = Math.abs(row - centerRow) + Math.abs(col - centerCol);
//             return distance < Math.min(this.length, this.width) * 0.3;
//         }

//         isValidMove(row, col) {
//             if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
//                 return false;
//             }
//             return this.grid[row][col].passable;
//         }

//         getMetrics() {
//             return { ...this.metrics };
//         }

//         resetMetrics() {
//             this.metrics = {
//                 pathLength: 0,
//                 turnCount: 0,
//                 computationTime: 0,
//                 nodesExplored: 0,
//                 congestionEncountered: 0
//             };
//         }
//     }

//     // Enhanced Multi-Objective A* Algorithm with metrics
//     class MultiObjectiveAStar {
//         constructor(floor, width, length, selectedItemIds) {
//             this.floor = floor;
//             this.width = width;
//             this.length = length;
//             this.selectedItemIds = selectedItemIds.map(id => id.toString());
            
//             // Multi-objective optimization weights
//             this.weights = {
//                 distance: 1.0,
//                 congestion: 0.4,
//                 accessibility: 0.3,
//                 shoppingFlow: 0.2,
//                 turnPenalty: 0.15
//             };
            
//             this.grid = this.createEnhancedNavigationGrid();
//             this.congestionMatrix = this.initializeCongestionMatrix();
//             this.accessibilityMatrix = this.initializeAccessibilityMatrix();
            
//             // Metrics tracking
//             this.metrics = {
//                 pathLength: 0,
//                 turnCount: 0,
//                 computationTime: 0,
//                 nodesExplored: 0,
//                 congestionEncountered: 0,
//                 congestionAvoidanceScore: 0,
//                 accessibilityScore: 0,
//                 flowOptimizationScore: 0
//             };
//         }

//         // Enhanced grid creation with proper blocking
//         createEnhancedNavigationGrid() {
//             const grid = Array(this.length).fill(null).map(() => 
//                 Array(this.width).fill(null).map(() => ({ passable: true, cost: 1.0 }))
//             );

//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;

//                 if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                     console.warn(`Invalid grid position: row=${row}, col=${col}`);
//                     return;
//                 }

//                 if (cell.mode === 'wall') {
//                     grid[row][col] = { passable: false, cost: Infinity };
//                 }
//                 else if (cell.mode === 'shelf') {
//                     // ALL shelves are impassable - you can't walk through them!
//                     grid[row][col] = { passable: false, cost: Infinity };
//                 }
//                 else if (cell.mode === 'checkout' || cell.mode === 'cart') {
//                     // These are special locations we can reach as destinations
//                     grid[row][col] = { passable: true, cost: 1.0 };
//                 }
//                 else if (cell.mode === 'entrance' || cell.mode === 'exit') {
//                     // Entrance and exit points are passable
//                     grid[row][col] = { passable: true, cost: 0.8 };
//                 }
//                 else {
//                     // Open space - apply congestion-based cost later
//                     const congestionLevel = this.getCongestionLevel(row, col);
//                     grid[row][col] = { 
//                         passable: true, 
//                         cost: 1.0 + (congestionLevel * 0.3) 
//                     };
//                 }
//             });

//             return grid;
//         }

//         // Multi-objective heuristic function
//         multiObjectiveHeuristic(current, goal, gScore, path) {
//             const [currentRow, currentCol] = current;
//             const [goalRow, goalCol] = goal;
            
//             const manhattanDistance = Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
//             const congestionPenalty = this.getCongestionLevel(currentRow, currentCol);
//             const accessibilityBonus = this.getAccessibilityBonus(goalRow, goalCol);
//             const flowBonus = this.getShoppingFlowBonus(current, goal);
//             const turnPenalty = this.calculateTurnPenalty(path, current);
            
//             const heuristic = 
//                 (this.weights.distance * manhattanDistance) +
//                 (this.weights.congestion * congestionPenalty) -
//                 (this.weights.accessibility * accessibilityBonus) -
//                 (this.weights.shoppingFlow * flowBonus) +
//                 (this.weights.turnPenalty * turnPenalty);
            
//             return Math.max(0, heuristic);
//         }

//         // Enhanced A* with multi-objective optimization and metrics tracking
//         findOptimalPath(start, end) {
//             const startTime = performance.now();
//             this.resetMetrics();

//             const startRow = Math.floor(start / this.width);
//             const startCol = start % this.width;
//             const endRow = Math.floor(end / this.width);
//             const endCol = end % this.width;

//             if (!this.isValidMove(startRow, startCol) || !this.isValidMove(endRow, endCol)) {
//                 console.error('Invalid start or end position');
//                 return null;
//             }

//             const openList = [{
//                 position: [startRow, startCol],
//                 path: [start],
//                 gScore: 0,
//                 fScore: this.multiObjectiveHeuristic([startRow, startCol], [endRow, endCol], 0, [start]),
//                 parent: null
//             }];
            
//             const closedList = new Set();
//             const bestGScores = new Map();

//             while (openList.length > 0) {
//                 openList.sort((a, b) => a.fScore - b.fScore);
//                 const current = openList.shift();
//                 this.metrics.nodesExplored++;
                
//                 const [row, col] = current.position;
//                 const positionKey = `${row},${col}`;

//                 if (closedList.has(positionKey)) continue;
//                 closedList.add(positionKey);

//                 // Track congestion encounters
//                 if (this.getCongestionLevel(row, col) > 0.5) {
//                     this.metrics.congestionEncountered++;
//                 }

//                 // Track accessibility score
//                 this.metrics.accessibilityScore += this.getAccessibilityBonus(row, col);

//                 if (row === endRow && col === endCol) {
//                     const endTime = performance.now();
//                     this.metrics.computationTime = endTime - startTime;
//                     this.metrics.pathLength = current.path.length;
//                     this.metrics.turnCount = this.calculateTurns(current.path);
//                     this.calculateAdvancedMetrics(current.path);
//                     return current.path;
//                 }

//                 const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                
//                 for (const [dx, dy] of directions) {
//                     const newRow = row + dx;
//                     const newCol = col + dy;
//                     const newIndex = newRow * this.width + newCol;
//                     const newPositionKey = `${newRow},${newCol}`;

//                     if (!this.isValidMove(newRow, newCol) || closedList.has(newPositionKey)) {
//                         continue;
//                     }

//                     const moveCost = this.calculateEnhancedMoveCost(
//                         [row, col], 
//                         [newRow, newCol], 
//                         current.path
//                     );

//                     const newGScore = current.gScore + moveCost;
//                     const newPath = [...current.path, newIndex];
                    
//                     const bestG = bestGScores.get(newPositionKey);
//                     if (bestG !== undefined && newGScore >= bestG) {
//                         continue;
//                     }
//                     bestGScores.set(newPositionKey, newGScore);

//                     const newFScore = newGScore + this.multiObjectiveHeuristic(
//                         [newRow, newCol], 
//                         [endRow, endCol], 
//                         newGScore,
//                         newPath
//                     );

//                     const existingIndex = openList.findIndex(node => 
//                         node.position[0] === newRow && node.position[1] === newCol
//                     );
                    
//                     if (existingIndex !== -1) {
//                         if (newGScore < openList[existingIndex].gScore) {
//                             openList.splice(existingIndex, 1);
//                         } else {
//                             continue;
//                         }
//                     }

//                     openList.push({
//                         position: [newRow, newCol],
//                         path: newPath,
//                         gScore: newGScore,
//                         fScore: newFScore,
//                         parent: current
//                     });
//                 }
//             }

//             const endTime = performance.now();
//             this.metrics.computationTime = endTime - startTime;
//             return null;
//         }

//         calculateTurns(path) {
//             if (path.length < 3) return 0;
            
//             let turns = 0;
//             for (let i = 2; i < path.length; i++) {
//                 const prev = path[i - 2];
//                 const curr = path[i - 1];
//                 const next = path[i];
                
//                 const prevRow = Math.floor(prev / this.width);
//                 const prevCol = prev % this.width;
//                 const currRow = Math.floor(curr / this.width);
//                 const currCol = curr % this.width;
//                 const nextRow = Math.floor(next / this.width);
//                 const nextCol = next % this.width;
                
//                 const dir1 = [currRow - prevRow, currCol - prevCol];
//                 const dir2 = [nextRow - currRow, nextCol - currCol];
                
//                 if (dir1[0] !== dir2[0] || dir1[1] !== dir2[1]) {
//                     turns++;
//                 }
//             }
//             return turns;
//         }

//         calculateAdvancedMetrics(path) {
//             let congestionAvoidance = 0;
//             let flowOptimization = 0;

//             for (let i = 0; i < path.length; i++) {
//                 const index = path[i];
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;

//                 // Congestion avoidance score (higher is better)
//                 const congestionLevel = this.getCongestionLevel(row, col);
//                 congestionAvoidance += (1 - congestionLevel);

//                 // Flow optimization score
//                 if (i > 0) {
//                     const prevIndex = path[i - 1];
//                     const prevRow = Math.floor(prevIndex / this.width);
//                     const prevCol = prevIndex % this.width;
//                     flowOptimization += this.getShoppingFlowBonus([prevRow, prevCol], [row, col]);
//                 }
//             }

//             this.metrics.congestionAvoidanceScore = congestionAvoidance / path.length;
//             this.metrics.flowOptimizationScore = flowOptimization / Math.max(1, path.length - 1);
//         }

//         getMetrics() {
//             return { ...this.metrics };
//         }

//         resetMetrics() {
//             this.metrics = {
//                 pathLength: 0,
//                 turnCount: 0,
//                 computationTime: 0,
//                 nodesExplored: 0,
//                 congestionEncountered: 0,
//                 congestionAvoidanceScore: 0,
//                 accessibilityScore: 0,
//                 flowOptimizationScore: 0
//             };
//         }

//         calculateEnhancedMoveCost(from, to, currentPath) {
//             const [toRow, toCol] = to;
            
//             const gridCell = this.grid[toRow][toCol];
//             let baseCost = gridCell.cost;
            
//             const congestionLevel = this.getCongestionLevel(toRow, toCol);
//             const congestionMultiplier = 1 + (congestionLevel * 0.3);
//             const turnPenalty = this.getDirectionChangePenalty(currentPath, [toRow, toCol]);
//             const accessibilityBonus = this.getAccessibilityBonus(toRow, toCol);
            
//             return (baseCost * congestionMultiplier) + turnPenalty - (accessibilityBonus * 0.1);
//         }

//         isValidMove(row, col) {
//             if (row < 0 || row >= this.length || col < 0 || col >= this.width) {
//                 return false;
//             }
            
//             if (!this.grid || !this.grid[row] || !this.grid[row][col]) {
//                 return false;
//             }
            
//             return this.grid[row][col].passable;
//         }

//         // Supporting methods (shortened for brevity - include all your existing methods)
//         initializeCongestionMatrix() {
//             const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
//             for (let i = 0; i < this.length; i++) {
//                 for (let j = 0; j < this.width; j++) {
//                     const centerDistance = Math.abs(i - this.length/2) + Math.abs(j - this.width/2);
//                     const maxDistance = (this.length + this.width) / 2;
//                     matrix[i][j] = Math.max(0, 1 - (centerDistance / maxDistance)) * 0.5;
//                     matrix[i][j] += Math.random() * 0.2;
//                 }
//             }
            
//             return matrix;
//         }

//         initializeAccessibilityMatrix() {
//             const matrix = Array(this.length).fill(null).map(() => Array(this.width).fill(0));
            
//             Object.entries(this.floor).forEach(([index, cell]) => {
//                 const row = Math.floor(index / this.width);
//                 const col = index % this.width;
                
//                 if (row >= this.length || col >= this.width || row < 0 || col < 0) {
//                     return;
//                 }
                
//                 if (cell.mode === 'shelf' && cell.itemIds) {
//                     const hasRequiredItems = cell.itemIds.some(id => 
//                         this.selectedItemIds.includes(id.toString())
//                     );
                    
//                     if (hasRequiredItems) {
//                         let freeSpaces = 0;
//                         const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        
//                         for (const [dx, dy] of directions) {
//                             const checkRow = row + dx;
//                             const checkCol = col + dy;
//                             if (this.isValidPosition(checkRow, checkCol)) {
//                                 freeSpaces++;
//                             }
//                         }
                        
//                         matrix[row][col] = freeSpaces / 4.0;
//                     }
//                 }
//             });
            
//             return matrix;
//         }

//         isValidPosition(row, col) {
//             return row >= 0 && row < this.length && col >= 0 && col < this.width;
//         }

//         getCongestionLevel(row, col) {
//             if (this.congestionMatrix[row] && this.congestionMatrix[row][col] !== undefined) {
//                 return this.congestionMatrix[row][col];
//             }
//             return 0;
//         }

//         getAccessibilityBonus(row, col) {
//             if (this.accessibilityMatrix[row] && this.accessibilityMatrix[row][col] !== undefined) {
//                 return this.accessibilityMatrix[row][col];
//             }
//             return 0;
//         }

//         getShoppingFlowBonus(current, goal) {
//             const [currentRow, currentCol] = current;
//             const [goalRow, goalCol] = goal;
            
//             const currentPerimeterDistance = Math.min(
//                 currentRow, currentCol, 
//                 this.length - 1 - currentRow, 
//                 this.width - 1 - currentCol
//             );
            
//             const goalPerimeterDistance = Math.min(
//                 goalRow, goalCol, 
//                 this.length - 1 - goalRow, 
//                 this.width - 1 - goalCol
//             );
            
//             if (currentPerimeterDistance <= goalPerimeterDistance) {
//                 return 0.3;
//             }
            
//             return 0;
//         }

//         calculateTurnPenalty(path, current) {
//             if (path.length < 2) return 0;
            
//             const [currentRow, currentCol] = current;
//             const lastIndex = path[path.length - 1];
//             const secondLastIndex = path[path.length - 2];
            
//             const lastRow = Math.floor(lastIndex / this.width);
//             const lastCol = lastIndex % this.width;
//             const secondLastRow = Math.floor(secondLastIndex / this.width);
//             const secondLastCol = secondLastIndex % this.width;
            
//             const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//             const newDirection = [currentRow - lastRow, currentCol - lastCol];
            
//             if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//                 return 0.2;
//             }
            
//             return 0;
//         }

//         getDirectionChangePenalty(path, newPosition) {
//             if (path.length < 2) return 0;
            
//             const [newRow, newCol] = newPosition;
//             const lastIndex = path[path.length - 1];
//             const secondLastIndex = path[path.length - 2];
            
//             const lastRow = Math.floor(lastIndex / this.width);
//             const lastCol = lastIndex % this.width;
//             const secondLastRow = Math.floor(secondLastIndex / this.width);
//             const secondLastCol = secondLastIndex % this.width;
            
//             const prevDirection = [lastRow - secondLastRow, lastCol - secondLastCol];
//             const newDirection = [newRow - lastRow, newCol - lastCol];
            
//             if (prevDirection[0] !== newDirection[0] || prevDirection[1] !== newDirection[1]) {
//                 return 0.15;
//             }
            
//             return 0;
//         }
//     }

//     class AlgorithmComparator {
//         constructor() {
//             this.comparisonResults = null;
//         }

//         async compareAlgorithms(floor, width, length, selectedItems, accessiblePositions, cart, exit) {
//             console.log('🔬 Starting Algorithm Comparison...');
            
//             const standardAStar = new StandardAStar(floor, width, length);
//             const multiObjectiveAStar = new MultiObjectiveAStar(floor, width, length, selectedItems);

//             const results = {
//                 standardAStar: {
//                     totalMetrics: this.initializeMetrics(),
//                     segmentMetrics: []
//                 },
//                 multiObjectiveAStar: {
//                     totalMetrics: this.initializeMetrics(),
//                     segmentMetrics: []
//                 },
//                 comparison: {}
//             };

//             // Test both algorithms on the same route segments
//             let currentLocation = cart.index;
            
//             for (let i = 0; i < accessiblePositions.length; i++) {
//                 const targetPosition = accessiblePositions[i];
                
//                 console.log(`Testing segment ${i + 1}: ${currentLocation} → ${targetPosition.index}`);

//                 // Test Standard A*
//                 const standardResult = await this.testAlgorithmSegment(
//                     standardAStar, 
//                     currentLocation, 
//                     targetPosition.index,
//                     `Standard A* - Segment ${i + 1}`
//                 );

//                 // Test Multi-Objective A*
//                 const multiObjectiveResult = await this.testAlgorithmSegment(
//                     multiObjectiveAStar, 
//                     currentLocation, 
//                     targetPosition.index,
//                     `Multi-Objective A* - Segment ${i + 1}`
//                 );

//                 results.standardAStar.segmentMetrics.push(standardResult);
//                 results.multiObjectiveAStar.segmentMetrics.push(multiObjectiveResult);

//                 // Accumulate total metrics
//                 this.accumulateMetrics(results.standardAStar.totalMetrics, standardResult);
//                 this.accumulateMetrics(results.multiObjectiveAStar.totalMetrics, multiObjectiveResult);

//                 currentLocation = targetPosition.index;
//             }

//             // Test final segment to exit
//             const standardExitResult = await this.testAlgorithmSegment(
//                 standardAStar, 
//                 currentLocation, 
//                 exit.index,
//                 'Standard A* - To Exit'
//             );

//             const multiObjectiveExitResult = await this.testAlgorithmSegment(
//                 multiObjectiveAStar, 
//                 currentLocation, 
//                 exit.index,
//                 'Multi-Objective A* - To Exit'
//             );

//             results.standardAStar.segmentMetrics.push(standardExitResult);
//             results.multiObjectiveAStar.segmentMetrics.push(multiObjectiveExitResult);
            
//             this.accumulateMetrics(results.standardAStar.totalMetrics, standardExitResult);
//             this.accumulateMetrics(results.multiObjectiveAStar.totalMetrics, multiObjectiveExitResult);

//             // Calculate averages and comparisons
//             this.calculateFinalMetrics(results);
//             this.generateComparison(results);

//             this.comparisonResults = results;
//             return results;
//         }

//         async testAlgorithmSegment(algorithm, start, end, description) {
//             const startTime = performance.now();
            
//             // Reset metrics before testing
//             if (algorithm.resetMetrics) {
//                 algorithm.resetMetrics();
//             }

//             const path = algorithm.findOptimalPath(start, end);
//             const endTime = performance.now();

//             const metrics = algorithm.getMetrics ? algorithm.getMetrics() : {
//                 pathLength: path ? path.length : 0,
//                 turnCount: 0,
//                 computationTime: endTime - startTime,
//                 nodesExplored: 0,
//                 congestionEncountered: 0
//             };

//             console.log(`${description}:`, metrics);

//             return {
//                 description,
//                 path,
//                 metrics,
//                 success: path !== null
//             };
//         }

//         initializeMetrics() {
//             return {
//                 pathLength: 0,
//                 turnCount: 0,
//                 computationTime: 0,
//                 nodesExplored: 0,
//                 congestionEncountered: 0,
//                 congestionAvoidanceScore: 0,
//                 accessibilityScore: 0,
//                 flowOptimizationScore: 0,
//                 segmentCount: 0
//             };
//         }

//         accumulateMetrics(totalMetrics, segmentResult) {
//             if (!segmentResult.success) return;

//             const metrics = segmentResult.metrics;
//             totalMetrics.pathLength += metrics.pathLength || 0;
//             totalMetrics.turnCount += metrics.turnCount || 0;
//             totalMetrics.computationTime += metrics.computationTime || 0;
//             totalMetrics.nodesExplored += metrics.nodesExplored || 0;
//             totalMetrics.congestionEncountered += metrics.congestionEncountered || 0;
//             totalMetrics.congestionAvoidanceScore += metrics.congestionAvoidanceScore || 0;
//             totalMetrics.accessibilityScore += metrics.accessibilityScore || 0;
//             totalMetrics.flowOptimizationScore += metrics.flowOptimizationScore || 0;
//             totalMetrics.segmentCount += 1;
//         }

//         calculateFinalMetrics(results) {
//             // Calculate averages for per-segment metrics
//             ['standardAStar', 'multiObjectiveAStar'].forEach(algorithmKey => {
//                 const metrics = results[algorithmKey].totalMetrics;
//                 if (metrics.segmentCount > 0) {
//                     metrics.avgComputationTime = metrics.computationTime / metrics.segmentCount;
//                     metrics.avgNodesExplored = metrics.nodesExplored / metrics.segmentCount;
//                     metrics.avgCongestionAvoidance = metrics.congestionAvoidanceScore / metrics.segmentCount;
//                     metrics.avgAccessibilityScore = metrics.accessibilityScore / metrics.segmentCount;
//                     metrics.avgFlowOptimization = metrics.flowOptimizationScore / metrics.segmentCount;
//                 }
//             });
//         }

//         generateComparison(results) {
//             const standard = results.standardAStar.totalMetrics;
//             const multiObjective = results.multiObjectiveAStar.totalMetrics;

//             results.comparison = {
//                 pathLengthImprovement: this.calculateImprovement(standard.pathLength, multiObjective.pathLength, true),
//                 turnCountImprovement: this.calculateImprovement(standard.turnCount, multiObjective.turnCount, true),
//                 computationTimeRatio: (multiObjective.computationTime / Math.max(standard.computationTime, 1)).toFixed(2),
//                 nodesExploredRatio: (multiObjective.nodesExplored / Math.max(standard.nodesExplored, 1)).toFixed(2),
//                 congestionHandlingImprovement: this.calculateImprovement(
//                     standard.congestionEncountered, 
//                     multiObjective.congestionEncountered, 
//                     true
//                 ),
//                 overallEfficiencyGain: this.calculateOverallEfficiency(standard, multiObjective)
//             };
//         }

//         calculateImprovement(standardValue, multiObjectiveValue, lowerIsBetter = false) {
//             if (standardValue === 0) return multiObjectiveValue === 0 ? 0 : (lowerIsBetter ? -100 : 100);
            
//             const improvement = ((standardValue - multiObjectiveValue) / standardValue) * 100;
//             return lowerIsBetter ? improvement : -improvement;
//         }

//         calculateOverallEfficiency(standard, multiObjective) {
//             // Weighted efficiency score considering multiple factors
//             const weights = {
//                 pathLength: 0.3,
//                 turnCount: 0.2,
//                 computationTime: 0.2,
//                 congestionHandling: 0.3
//             };

//             let efficiencyGain = 0;
//             efficiencyGain += weights.pathLength * this.calculateImprovement(standard.pathLength, multiObjective.pathLength, true);
//             efficiencyGain += weights.turnCount * this.calculateImprovement(standard.turnCount, multiObjective.turnCount, true);
//             efficiencyGain += weights.computationTime * this.calculateImprovement(standard.computationTime, multiObjective.computationTime, true);
//             efficiencyGain += weights.congestionHandling * this.calculateImprovement(standard.congestionEncountered, multiObjective.congestionEncountered, true);

//             return efficiencyGain.toFixed(2);
//         }

//         displayComparison() {
//             if (!this.comparisonResults) {
//                 console.log('No comparison results available');
//                 return;
//             }

//             const results = this.comparisonResults;
//             const standard = results.standardAStar.totalMetrics;
//             const multiObjective = results.multiObjectiveAStar.totalMetrics;
//             const comparison = results.comparison;

//             console.log('\n🏆 ALGORITHM COMPARISON RESULTS 🏆');
//             console.log('=' .repeat(60));
            
//             console.log('\n📊 PATH METRICS:');
//             console.log(`Standard A* Path Length: ${standard.pathLength} steps`);
//             console.log(`Multi-Objective A* Path Length: ${multiObjective.pathLength} steps`);
//             console.log(`Path Length Improvement: ${comparison.pathLengthImprovement.toFixed(2)}%`);
            
//             console.log('\n🔄 TURN ANALYSIS:');
//             console.log(`Standard A* Turns: ${standard.turnCount}`);
//             console.log(`Multi-Objective A* Turns: ${multiObjective.turnCount}`);
//             console.log(`Turn Count Improvement: ${comparison.turnCountImprovement.toFixed(2)}%`);
            
//             console.log('\n⚡ PERFORMANCE METRICS:');
//             console.log(`Standard A* Computation Time: ${standard.computationTime.toFixed(2)}ms`);
//             console.log(`Multi-Objective A* Computation Time: ${multiObjective.computationTime.toFixed(2)}ms`);
//             console.log(`Computation Time Ratio: ${comparison.computationTimeRatio}x`);
            
//             console.log('\n🧠 SEARCH EFFICIENCY:');
//             console.log(`Standard A* Nodes Explored: ${standard.nodesExplored}`);
//             console.log(`Multi-Objective A* Nodes Explored: ${multiObjective.nodesExplored}`);
//             console.log(`Nodes Explored Ratio: ${comparison.nodesExploredRatio}x`);
            
//             console.log('\n🚦 CONGESTION HANDLING:');
//             console.log(`Standard A* Congestion Encounters: ${standard.congestionEncountered}`);
//             console.log(`Multi-Objective A* Congestion Encounters: ${multiObjective.congestionEncountered}`);
//             console.log(`Congestion Handling Improvement: ${comparison.congestionHandlingImprovement.toFixed(2)}%`);
            
//             console.log('\n🎯 ADVANCED METRICS (Multi-Objective Only):');
//             console.log(`Average Congestion Avoidance Score: ${multiObjective.avgCongestionAvoidance?.toFixed(3) || 'N/A'}`);
//             console.log(`Average Accessibility Score: ${multiObjective.avgAccessibilityScore?.toFixed(3) || 'N/A'}`);
//             console.log(`Average Flow Optimization Score: ${multiObjective.avgFlowOptimization?.toFixed(3) || 'N/A'}`);
            
//             console.log('\n🏅 OVERALL PERFORMANCE:');
//             console.log(`Overall Efficiency Gain: ${comparison.overallEfficiencyGain}%`);
            
//             console.log('\n📈 SUMMARY:');
//             if (parseFloat(comparison.overallEfficiencyGain) > 0) {
//                 console.log('✅ Multi-Objective A* shows superior performance');
//             } else {
//                 console.log('⚠️ Standard A* shows better performance in this scenario');
//             }
            
//             console.log('=' .repeat(60));
            
//             return this.createComparisonDisplay();
//         }

//         createComparisonDisplay() {
//             const results = this.comparisonResults;
//             const standard = results.standardAStar.totalMetrics;
//             const multiObjective = results.multiObjectiveAStar.totalMetrics;
//             const comparison = results.comparison;

//             return {
//                 pathLength: {
//                     standard: standard.pathLength,
//                     multiObjective: multiObjective.pathLength,
//                     improvement: comparison.pathLengthImprovement
//                 },
//                 turnCount: {
//                     standard: standard.turnCount,
//                     multiObjective: multiObjective.turnCount,
//                     improvement: comparison.turnCountImprovement
//                 },
//                 computationTime: {
//                     standard: standard.computationTime,
//                     multiObjective: multiObjective.computationTime,
//                     ratio: comparison.computationTimeRatio
//                 },
//                 congestionHandling: {
//                     standard: standard.congestionEncountered,
//                     multiObjective: multiObjective.congestionEncountered,
//                     improvement: comparison.congestionHandlingImprovement
//                 },
//                 overallEfficiency: comparison.overallEfficiencyGain
//             };
//         }
//     }
    

//     // Enhanced Navigator with intelligent shelf ordering
//     class EnhancedSupermarketNavigator extends SupermarketNavigator {
//         constructor(floor, width, length) {
//             super(floor, width, length);
//         }

//         optimizeShelfOrder(shelves, startLocation) {
//             if (shelves.length <= 1) return shelves;
            
//             const points = [startLocation, ...shelves];
//             const distances = this.calculateDistanceMatrix(points);
            
//             const optimizedOrder = [];
//             let currentIndex = 0;
//             const unvisited = new Set(Array.from({length: shelves.length}, (_, i) => i + 1));
            
//             while (unvisited.size > 0) {
//                 let nearestIndex = -1;
//                 let nearestDistance = Infinity;
                
//                 for (const index of unvisited) {
//                     let distance = distances[currentIndex][index];
                    
//                     const flowBonus = this.calculateShoppingFlowBonus(
//                         points[currentIndex], 
//                         points[index]
//                     );
//                     distance -= flowBonus;
                    
//                     if (distance < nearestDistance) {
//                         nearestDistance = distance;
//                         nearestIndex = index;
//                     }
//                 }
                
//                 unvisited.delete(nearestIndex);
//                 optimizedOrder.push(shelves[nearestIndex - 1]);
//                 currentIndex = nearestIndex;
//             }
            
//             return optimizedOrder;
//         }

//         calculateDistanceMatrix(points) {
//             const matrix = Array(points.length).fill().map(() => Array(points.length).fill(0));
            
//             for (let i = 0; i < points.length; i++) {
//                 for (let j = 0; j < points.length; j++) {
//                     if (i !== j) {
//                         const point1 = points[i];
//                         const point2 = points[j];
//                         matrix[i][j] = Math.abs(point1.row - point2.row) + 
//                                       Math.abs(point1.col - point2.col);
//                     }
//                 }
//             }
            
//             return matrix;
//         }

//         calculateShoppingFlowBonus(point1, point2) {
//             if (point1.row <= point2.row && point1.col <= point2.col) {
//                 return 0.5;
//             }
//             return 0;
//         }
//     }

//     // Enhanced RouteVisualizer class with numbered shelf markers
//     class RouteVisualizer {
//         constructor(gridContainer, width) {
//             this.gridContainer = gridContainer;
//             this.width = width;
//             this.svgContainer = null;
//         }

//         getGridItemCenter(index) {
//             if (index === undefined || index === null) {
//                 return null;
//             }

//             const gridItem = this.gridContainer.children[index];
//             if (!gridItem) {
//                 return null;
//             }

//             const containerRect = this.gridContainer.getBoundingClientRect();
//             const itemRect = gridItem.getBoundingClientRect();

//             return {
//                 x: itemRect.left - containerRect.left + itemRect.width / 2,
//                 y: itemRect.top - containerRect.top + itemRect.height / 2
//             };
//         }

//         createSVGContainer() {
//             const existingSvg = this.gridContainer.querySelector('svg.route-svg');
//             if (existingSvg) existingSvg.remove();

//             const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
//             svg.classList.add('route-svg');
//             svg.style.position = 'absolute';
//             svg.style.top = '0';
//             svg.style.left = '0';
//             svg.style.width = '100%';
//             svg.style.height = '100%';
//             svg.style.pointerEvents = 'none';
//             svg.style.zIndex = '45';

//             this.gridContainer.style.position = 'relative';
//             this.gridContainer.appendChild(svg);
//             this.svgContainer = svg;

//             return svg;
//         }

//         createArrowMarker(svg) {
//             const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
//             const linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
//             linearGradient.setAttribute('id', 'blueGradient');
//             linearGradient.setAttribute('x1', '0%');
//             linearGradient.setAttribute('y1', '0%');
//             linearGradient.setAttribute('x2', '100%');
//             linearGradient.setAttribute('y2', '0%');

//             const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop1.setAttribute('offset', '0%');
//             stop1.setAttribute('stop-color', '#3498db');

//             const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
//             stop2.setAttribute('offset', '100%');
//             stop2.setAttribute('stop-color', '#2ecc71');

//             linearGradient.appendChild(stop1);
//             linearGradient.appendChild(stop2);

//             const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
//             marker.setAttribute('id', 'arrow');
//             marker.setAttribute('markerWidth', '10');
//             marker.setAttribute('markerHeight', '7');
//             marker.setAttribute('refX', '5');
//             marker.setAttribute('refY', '3.5');
//             marker.setAttribute('orient', 'auto');

//             const arrowhead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
//             arrowhead.setAttribute('points', '0 0, 10 3.5, 0 7');
//             arrowhead.setAttribute('fill', 'url(#blueGradient)');

//             marker.appendChild(arrowhead);
//             defs.appendChild(linearGradient);
//             defs.appendChild(marker);

//             svg.appendChild(defs);
//         }

//         drawRoutePath(start, end, svg) {
//             if (!start || !end) {
//                 return null;
//             }

//             const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
//             path.setAttribute('d', `M ${start.x} ${start.y} L ${end.x} ${end.y}`);
//             path.setAttribute('stroke', 'url(#blueGradient)');
//             path.setAttribute('stroke-width', '4');
//             path.setAttribute('fill', 'none');
//             path.setAttribute('marker-end', 'url(#arrow)');

//             return path;
//         }

//         // NEW: Create numbered markers for shelves
//         createShelfMarker(svg, position, number, items) {
//             const center = this.getGridItemCenter(position);
//             if (!center) return null;

//             // Create marker group
//             const markerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
//             markerGroup.setAttribute('class', 'shelf-marker');

//             // Create circle background
//             const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
//             circle.setAttribute('cx', center.x);
//             circle.setAttribute('cy', center.y);
//             circle.setAttribute('r', '18');
//             circle.setAttribute('fill', '#e74c3c');
//             circle.setAttribute('stroke', '#ffffff');
//             circle.setAttribute('stroke-width', '3');
//             circle.setAttribute('opacity', '0.9');

//             // Create number text
//             const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
//             text.setAttribute('x', center.x);
//             text.setAttribute('y', center.y + 6);
//             text.setAttribute('text-anchor', 'middle');
//             text.setAttribute('fill', '#ffffff');
//             text.setAttribute('font-family', 'Arial, sans-serif');
//             text.setAttribute('font-size', '16');
//             text.setAttribute('font-weight', 'bold');
//             text.textContent = number;

//             // Create tooltip title for hover effect
//             const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
//             title.textContent = `Stop ${number}: Items - ${items.join(', ')}`;

//             markerGroup.appendChild(circle);
//             markerGroup.appendChild(text);
//             markerGroup.appendChild(title);

//             return markerGroup;
//         }

//         // NEW: Clear existing markers
//         clearShelfMarkers() {
//             const existingMarkers = this.gridContainer.querySelectorAll('.shelf-marker-overlay');
//             existingMarkers.forEach(marker => marker.remove());
//         }

//         // Enhanced visualizeRoute method with shelf markers
//         visualizeRoute(route, optimizedPositions = []) {
//             const svg = this.createSVGContainer();
//             this.createArrowMarker(svg);

//             // Clear existing markers
//             this.clearShelfMarkers();

//             // Highlight route path
//             route.forEach(index => {
//                 const gridItem = this.gridContainer.children[index];
//                 if (gridItem) {
//                     gridItem.classList.add('route-highlight');
//                 }
//             });

//             // Draw route lines
//             for (let i = 0; i < route.length - 1; i++) {
//                 const start = this.getGridItemCenter(route[i]);
//                 const end = this.getGridItemCenter(route[i + 1]);

//                 if (start && end) {
//                     const routePath = this.drawRoutePath(start, end, svg);
//                     if (routePath) {
//                         svg.appendChild(routePath);
//                     }
//                 }
//             }

//             // Add numbered markers for shelf positions
//             optimizedPositions.forEach((position, index) => {
//                 const marker = this.createShelfMarker(
//                     svg, 
//                     position.targetShelf.index, 
//                     index + 1, 
//                     position.items
//                 );
//                 if (marker) {
//                     svg.appendChild(marker);
//                 }
//             });
//         }
//     }

//     // Enhanced CSS
//     const styleSheet = document.createElement('style');
//     styleSheet.textContent = `
//         .route-highlight {
//             // background-color: rgba(52, 152, 219, 0.3) !important;
//             // transition: background-color 0.3s ease;
//             // box-shadow: inset 0 0 0 2px #3498db;
//         }
        
//         .shelf-marker {
//             cursor: pointer;
//             transition: all 0.3s ease;
//         }
        
//         .shelf-marker:hover {
//             transform: scale(1.1);
//         }
        
//         .shelf-marker circle {
//             filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
//         }
        
//         .comparison-results {
//             background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
//             color: white;
//             padding: 15px;
//             border-radius: 10px;
//             margin: 10px 0;
//             font-family: 'Courier New', monospace;
//             font-size: 12px;
//             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
//         }
        
//         .metric-row {
//             display: flex;
//             justify-content: space-between;
//             margin: 5px 0;
//             padding: 3px 0;
//             border-bottom: 1px solid rgba(255, 255, 255, 0.1);
//         }
        
//         .metric-improvement {
//             color: #2ecc71;
//             font-weight: bold;
//         }
        
//         .metric-degradation {
//             color: #e74c3c;
//             font-weight: bold;
//         }
        
//         .metric-neutral {
//             color: #f39c12;
//             font-weight: bold;
//         }
        
//         .comparison-header {
//             text-align: center;
//             font-size: 14px;
//             font-weight: bold;
//             margin-bottom: 10px;
//             color: #3498db;
//         }
        
//         .shelf-info {
//             background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
//             color: white;
//             padding: 8px;
//             border-radius: 6px;
//             margin-top: 5px;
//             font-size: 12px;
//         }
//     `;
//     document.head.appendChild(styleSheet);

//     // MAIN: Enhanced route finding implementation with algorithm comparison
//     findRouteBtn.addEventListener('click', async function() {
//         const selectedItems = Array.from(
//             itemsSelect.selectedOptions
//         ).map(option => option.value);

//         if (selectedItems.length === 0) {
//             alert('Please select at least one item');
//             return;
//         }

//         console.log('🚀 Starting Enhanced Route Finding with Algorithm Comparison...');

//         const navigator = new EnhancedSupermarketNavigator(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }}
//         );

//         const pathFinder = new MultiObjectiveAStar(
//             {{ floor_data_json|safe }}, 
//             {{ floor.width }}, 
//             {{ floor.length }},
//             selectedItems  
//         );

//         // Find key locations
//         const entrance = navigator.findFirstCellOfMode('entrance');
//         const cart = navigator.findFirstCellOfMode('cart');
//         const exit = navigator.findFirstCellOfMode('exit');

//         // Find shelves with selected items
//         const itemShelves = navigator.findShelvesWithItems(selectedItems);

//         if (!entrance || !cart || !exit || itemShelves.length === 0) {
//             alert('Could not find all required locations or items');
//             return;
//         }

//         // Find accessible positions adjacent to shelves
//         const accessibleShelfPositions = navigator.findAccessibleShelfPositions(itemShelves, pathFinder);

//         if (accessibleShelfPositions.length === 0) {
//             alert('Could not find accessible positions near the required items');
//             return;
//         }

//         // Optimize the order of accessible shelf positions
//         const optimizedPositions = navigator.optimizeShelfOrder(accessibleShelfPositions, cart);

//         // 🔬 ALGORITHM COMPARISON
//         console.log('🔬 Running Algorithm Comparison...');
//         const comparator = new AlgorithmComparator();
        
//         try {
//             const comparisonResults = await comparator.compareAlgorithms(
//                 {{ floor_data_json|safe }},
//                 {{ floor.width }},
//                 {{ floor.length }},
//                 selectedItems,
//                 optimizedPositions,
//                 cart,
//                 exit
//             );

//             // Display detailed comparison
//             const displayResults = comparator.displayComparison();
            
//             // Create visual comparison display
//             const comparisonDiv = createComparisonDisplay(displayResults);
//             const existingComparison = document.querySelector('.comparison-results');
//             if (existingComparison) existingComparison.remove();
            
//             // Uncomment to show comparison results
//             // gridContainer.parentNode.insertBefore(comparisonDiv, gridContainer);

//         } catch (error) {
//             console.error('Comparison failed:', error);
//         }

//         // Continue with Multi-Objective A* route generation
//         let currentLocation = cart.index;
//         let fullRoute = [currentLocation];

//         // Route to each accessible shelf position in optimized order
//         for (const shelfPosition of optimizedPositions) {
//             const toShelfPath = pathFinder.findOptimalPath(currentLocation, shelfPosition.index);
//             if (toShelfPath && toShelfPath.length > 1) {
//                 fullRoute = fullRoute.concat(toShelfPath.slice(1));
//                 currentLocation = shelfPosition.index;
//                 console.log(`Routed to accessible position ${shelfPosition.index} for shelf ${shelfPosition.targetShelf.index}`);
//             }
//         }

//         // Route to exit
//         const toExitPath = pathFinder.findOptimalPath(currentLocation, exit.index);
//         if (toExitPath && toExitPath.length > 1) {
//             fullRoute = fullRoute.concat(toExitPath.slice(1));
//         }

//         // Display optimization info with shelf details
//         const shelfDetails = optimizedPositions.map((pos, index) => 
//             `${index + 1}. Items: ${pos.items.join(', ')}`
//         ).join('<br>');

//         const infoDiv = document.createElement('div');
//         infoDiv.className = 'optimal-path-info';
//         infoDiv.innerHTML = `
//             <strong>🎯 Enhanced Multi-Objective Route Generated</strong><br>
//             📊 Total Path Length: ${fullRoute.length} steps<br>
//             🛒 Visiting ${optimizedPositions.length} item locations<br>
//             ⚡ Using: Shelf accessibility + Congestion avoidance + Flow optimization
//             <div class="shelf-info">
//                 <strong>📍 Numbered Shelf Stops:</strong><br>
//                 ${shelfDetails}
//             </div>
//         `;
        
//         const existingInfo = document.querySelector('.optimal-path-info');
//         if (existingInfo) existingInfo.remove();
        
//         // Uncomment the line below if you want to show the info panel
//         // gridContainer.parentNode.insertBefore(infoDiv, gridContainer);

//         // Visualize the enhanced route with numbered shelf markers
//         const visualizer = new RouteVisualizer(gridContainer, {{ floor.width }});
//         visualizer.visualizeRoute(fullRoute, optimizedPositions);

//         console.log('=== RESEARCH METRICS ===');
//         console.log('Algorithm: Multi-Objective A* with Shelf Accessibility');
//         console.log('Path length:', fullRoute.length);
//         console.log('Accessible positions found:', accessibleShelfPositions.length);
//         console.log('Route includes item pickup locations:', optimizedPositions.map(p => p.index));
//         console.log('Shelf markers created for:', optimizedPositions.map((p, i) => `${i+1}: Items ${p.items.join(',')}`));
//         console.log('========================');
//     });

//     // Helper function to create comparison display
//     function createComparisonDisplay(results) {
//         const div = document.createElement('div');
//         div.className = 'comparison-results';
        
//         const getImprovementClass = (value) => {
//             if (value > 5) return 'metric-improvement';
//             if (value < -5) return 'metric-degradation';
//             return 'metric-neutral';
//         };

//         div.innerHTML = `
//             <div class="comparison-header">🏆 Algorithm Performance Comparison</div>
            
//             <div class="metric-row">
//                 <span>📏 Path Length:</span>
//                 <span>Standard: ${results.pathLength.standard} | Multi-Objective: ${results.pathLength.multiObjective}</span>
//                 <span class="${getImprovementClass(results.pathLength.improvement)}">${results.pathLength.improvement.toFixed(1)}%</span>
//             </div>
            
//             <div class="metric-row">
//                 <span>🔄 Turn Count:</span>
//                 <span>Standard: ${results.turnCount.standard} | Multi-Objective: ${results.turnCount.multiObjective}</span>
//                 <span class="${getImprovementClass(results.turnCount.improvement)}">${results.turnCount.improvement.toFixed(1)}%</span>
//             </div>
            
//             <div class="metric-row">
//                 <span>⚡ Computation Time:</span>
//                 <span>Ratio: ${results.computationTime.ratio}x</span>
//                 <span class="${results.computationTime.ratio < 1.2 ? 'metric-improvement' : 'metric-degradation'}">
//                     ${results.computationTime.ratio < 1 ? 'Faster' : 'Slower'}
//                 </span>
//             </div>
            
//             <div class="metric-row">
//                 <span>🚦 Congestion Handling:</span>
//                 <span>Standard: ${results.congestionHandling.standard} | Multi-Objective: ${results.congestionHandling.multiObjective}</span>
//                 <span class="${getImprovementClass(results.congestionHandling.improvement)}">${results.congestionHandling.improvement.toFixed(1)}%</span>
//             </div>
            
//             <div class="metric-row" style="border-top: 2px solid #3498db; margin-top: 10px; padding-top: 8px;">
//                 <span><strong>🏅 Overall Efficiency:</strong></span>
//                 <span class="${getImprovementClass(parseFloat(results.overallEfficiency))}">
//                     <strong>${results.overallEfficiency}% ${parseFloat(results.overallEfficiency) > 0 ? 'Better' : 'Worse'}</strong>
//                 </span>
//             </div>
//         `;
        
//         return div;
//     }
// });







// ---------------------------



// continuous web request ajax
// document.addEventListener('DOMContentLoaded', function() {
//     // Create a container for the real-time data
//     const dataContainer = document.createElement('div');
//     dataContainer.id = 'real-time-detection';
//     dataContainer.className = 'real-time-detection-container';
//     dataContainer.style.cssText = 'position: fixed; bottom: 20px; left: 20px; padding: 15px; background-color: #fff; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 300px; max-height: 400px; overflow-y: auto; z-index: 1000;';
    
//     const header = document.createElement('h3');
//     header.textContent = 'Items in Cart';
//     header.style.margin = '0 0 10px 0';
//     dataContainer.appendChild(header);
    
//     const itemsList = document.createElement('ul');
//     itemsList.id = 'detected-items-list';
//     itemsList.style.cssText = 'list-style: none; padding: 0; margin: 0;';
//     dataContainer.appendChild(itemsList);
    
//     document.body.appendChild(dataContainer);
    
//     // Function to update the displayed items
//     function updateDetectedItems() {
//         fetch('/api/get-detected-items/')
//             .then(response => response.json())
//             .then(data => {
//                 if (data.status === 'success') {
//                     const itemsList = document.getElementById('detected-items-list');
//                     itemsList.innerHTML = '';
                    
//                     // Display detected items
//                     if (data.detected_items && data.detected_items.length > 0) {
//                         const detectedItemsHeader = document.createElement('li');
//                         detectedItemsHeader.style.fontWeight = 'bold';
//                         detectedItemsHeader.style.marginTop = '10px';
//                         // detectedItemsHeader.textContent = 'Items in Cart:';
//                         itemsList.appendChild(detectedItemsHeader);
                        
//                         data.detected_items.forEach(item => {
//                             const li = document.createElement('li');
//                             li.textContent = item;
//                             li.style.padding = '5px 0';
//                             //itemsList.appendChild(li);
//                         });
//                     }
                    
//                     // Display matched items with details
//                     if (data.matched_items && data.matched_items.length > 0) {
//                         const matchedItemsHeader = document.createElement('li');
//                         matchedItemsHeader.style.fontWeight = 'bold';
//                         matchedItemsHeader.style.marginTop = '10px';
//                         // matchedItemsHeader.textContent = 'Matched Database Items:';
//                         itemsList.appendChild(matchedItemsHeader);
                        
//                         data.matched_items.forEach(item => {
//                             const li = document.createElement('li');
//                             li.style.padding = '5px 0';
//                             li.style.borderBottom = '1px solid #eee';
                            
//                             const itemName = document.createElement('div');
//                             itemName.textContent = item.name;
//                             itemName.style.fontWeight = 'bold';
                            
//                             const itemDetails = document.createElement('div');
//                             itemDetails.style.fontSize = '0.9em';
//                             itemDetails.style.color = '#666';
//                             itemDetails.innerHTML = `Price: ₹${item.price} | Qty: ${item.quantity}<br>
//                                                    ${item.description}`;
                            
//                             li.appendChild(itemName);
//                             li.appendChild(itemDetails);
//                             itemsList.appendChild(li);
//                         });
//                     }
                    
//                     // If no items found
//                     if ((!data.detected_items || data.detected_items.length === 0) && 
//                         (!data.matched_items || data.matched_items.length === 0)) {
//                         const li = document.createElement('li');
//                         li.textContent = 'No items detected yet';
//                         li.style.fontStyle = 'italic';
//                         li.style.color = '#888';
//                         itemsList.appendChild(li);
//                     }
                    
//                     // Log to console
//                     console.log('Real-time detection update:', data);
//                 }
//             })
//             .catch(error => {
//                 console.error('Error fetching real-time detection data:', error);
//             });
//     }
    
//     // Initial update
//     updateDetectedItems();
    
//     // Set up polling every 2 seconds
//     setInterval(updateDetectedItems, 2000);
    
//     // Add toggle button to show/hide the data panel
//     const toggleButton = document.createElement('button');
//     toggleButton.textContent = 'Hide Cart';
//     toggleButton.style.cssText = 'position: fixed; bottom: 20px; right: 30px; padding: 5px 10px; background-color: #4285f4; color: white; border: none; border-radius: 3px; cursor: pointer; z-index: 1000;';
//     document.body.appendChild(toggleButton);
    
//     toggleButton.addEventListener('click', function() {
//         if (dataContainer.style.display === 'none') {
//             dataContainer.style.display = 'block';
//             toggleButton.textContent = 'Hide Cart';
//         } else {
//             dataContainer.style.display = 'none';
//             toggleButton.textContent = 'Show Cart';
//         }
//     });
// });


// WebSocket implementation 1
// document.addEventListener('DOMContentLoaded', function() {
//     // Create a container for the real-time data
//     const dataContainer = document.createElement('div');
//     dataContainer.id = 'real-time-detection';
//     dataContainer.className = 'real-time-detection-container';
//     dataContainer.style.cssText = 'position: fixed; bottom: 20px; left: 20px; padding: 15px; background-color: #fff; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 300px; max-height: 400px; overflow-y: auto; z-index: 1000;';
    
//     const header = document.createElement('h3');
//     header.textContent = 'Items in Cart';
//     header.style.margin = '0 0 10px 0';
//     dataContainer.appendChild(header);
    
//     const itemsList = document.createElement('ul');
//     itemsList.id = 'detected-items-list';
//     itemsList.style.cssText = 'list-style: none; padding: 0; margin: 0;';
//     dataContainer.appendChild(itemsList);
    
//     document.body.appendChild(dataContainer);
    
//     // Function to update the displayed items
//     function updateDetectedItemsDisplay(data) {
//         const itemsList = document.getElementById('detected-items-list');
//         itemsList.innerHTML = '';
        
//         // Display matched items with details
//         if (data.matched_items && data.matched_items.length > 0) {
//             data.matched_items.forEach(item => {
//                 const li = document.createElement('li');
//                 li.style.padding = '5px 0';
//                 li.style.borderBottom = '1px solid #eee';
                
//                 const itemName = document.createElement('div');
//                 itemName.textContent = item.name;
//                 itemName.style.fontWeight = 'bold';
                
//                 const itemDetails = document.createElement('div');
//                 itemDetails.style.fontSize = '0.9em';
//                 itemDetails.style.color = '#666';
//                 itemDetails.innerHTML = `Price: ₹${item.price} | Qty: ${item.quantity}<br>
//                                        ${item.description}`;
                
//                 li.appendChild(itemName);
//                 li.appendChild(itemDetails);
//                 itemsList.appendChild(li);
//             });
//         } else {
//             // If no items found
//             const li = document.createElement('li');
//             li.textContent = 'No items detected yet';
//             li.style.fontStyle = 'italic';
//             li.style.color = '#888';
//             itemsList.appendChild(li);
//         }
//     }
    
//     // Set up WebSocket connection
//     // Use secure WebSocket if the page is served over HTTPS
//     const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
//     // const wsUrl = `${protocol}//${window.location.host}/ws/cart/`;
//     const wsUrl = window.location.protocol === 'https:' ? `wss://${window.location.host}/ws/cart/` : `ws://${window.location.host}/ws/cart/`;
//     const cartSocket = new WebSocket(wsUrl);
    
//     cartSocket.onopen = function(e) {
//         console.log('WebSocket connection established');
//     };
    
//     cartSocket.onmessage = function(e) {
//         const data = JSON.parse(e.data);
//         console.log('WebSocket message received:', data);
//         updateDetectedItemsDisplay(data);
//     };
    
//     cartSocket.onclose = function(e) {
//         console.warn('WebSocket connection closed. Attempting to reconnect in 5 seconds...');
//         // Try to reconnect after 5 seconds
//         setTimeout(() => {
//             location.reload(); // Simple reconnection strategy
//         }, 5000);
//     };
    
//     cartSocket.onerror = function(err) {
//         console.error('WebSocket error:', err);
//     };
    
//     // Add toggle button to show/hide the data panel
//     const toggleButton = document.createElement('button');
//     toggleButton.textContent = 'Hide Cart';
//     toggleButton.style.cssText = 'position: fixed; bottom: 20px; right: 30px; padding: 5px 10px; background-color: #4285f4; color: white; border: none; border-radius: 3px; cursor: pointer; z-index: 1000;';
//     document.body.appendChild(toggleButton);
    
//     toggleButton.addEventListener('click', function() {
//         if (dataContainer.style.display === 'none') {
//             dataContainer.style.display = 'block';
//             toggleButton.textContent = 'Hide Cart';
//         } else {
//             dataContainer.style.display = 'none';
//             toggleButton.textContent = 'Show Cart';
//         }
//     });
// });


// 2
document.addEventListener('DOMContentLoaded', function() {
    // Create a container for the real-time data
    const dataContainer = document.createElement('div');
    dataContainer.id = 'real-time-detection';
    dataContainer.className = 'real-time-detection-container';
    dataContainer.style.cssText = 'position: fixed; bottom: 70px; left: 20px; padding: 15px; background-color: #fff; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 300px; max-height: 400px; overflow-y: auto; z-index: 1000;';
    
    const header = document.createElement('h3');
    header.textContent = 'Items in Cart';
    header.style.margin = '0 0 10px 0';
    dataContainer.appendChild(header);
    
    const itemsList = document.createElement('ul');
    itemsList.id = 'detected-items-list';
    itemsList.style.cssText = 'list-style: none; padding: 0; margin: 0;';
    dataContainer.appendChild(itemsList);
    
    // Add Pay button
    const payButton = document.createElement('button');
    payButton.textContent = 'Pay Now';
    payButton.style.cssText = 'width: 100%; margin-top: 15px; padding: 8px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;';
    dataContainer.appendChild(payButton);
    
    // Pay button click handler
    payButton.addEventListener('click', function() {
        // Check if there are items in the cart
        const itemsList = document.getElementById('detected-items-list');
        const noItemsMessage = itemsList.querySelector('li[style*="italic"]');
        
        if (noItemsMessage && noItemsMessage.textContent === 'No items detected yet') {
            alert('Your cart is empty. Please add items before proceeding to payment.');
            return;
        }
        
        // Navigate to payment confirmation page
        window.location.href = '/payment-confirmation/';
    });
    
    document.body.appendChild(dataContainer);
    
    // Function to update the displayed items
    function updateDetectedItemsDisplay(data) {
        const itemsList = document.getElementById('detected-items-list');
        itemsList.innerHTML = '';
        
        // Display matched items with details
        if (data.matched_items && data.matched_items.length > 0) {
            data.matched_items.forEach(item => {
                const li = document.createElement('li');
                li.style.padding = '5px 0';
                li.style.borderBottom = '1px solid #eee';
                
                const itemName = document.createElement('div');
                itemName.textContent = item.name;
                itemName.style.fontWeight = 'bold';
                
                const itemDetails = document.createElement('div');
                itemDetails.style.fontSize = '0.9em';
                itemDetails.style.color = '#666';
                itemDetails.innerHTML = `Price: ₹${item.price} | Qty: ${item.quantity}<br>
                                       ${item.description}`;
                
                li.appendChild(itemName);
                li.appendChild(itemDetails);
                itemsList.appendChild(li);
            });
        } else {
            // If no items found
            const li = document.createElement('li');
            li.textContent = 'No items detected yet';
            li.style.fontStyle = 'italic';
            li.style.color = '#888';
            itemsList.appendChild(li);
        }
    }
    
    // Set up WebSocket connection
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = window.location.protocol === 'https:' ? `wss://${window.location.host}/ws/cart/` : `ws://${window.location.host}/ws/cart/`;
    const cartSocket = new WebSocket(wsUrl);
    
    cartSocket.onopen = function(e) {
        console.log('WebSocket connection established');
    };
    
    cartSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        console.log('WebSocket message received:', data);
        updateDetectedItemsDisplay(data);
    };
    
    cartSocket.onclose = function(e) {
        console.warn('WebSocket connection closed. Attempting to reconnect in 5 seconds...');
        // Try to reconnect after 5 seconds
        setTimeout(() => {
            location.reload(); // Simple reconnection strategy
        }, 5000);
    };
    
    cartSocket.onerror = function(err) {
        console.error('WebSocket error:', err);
    };
    
    // Add toggle button to show/hide the data panel
    const toggleButton = document.createElement('button');
    toggleButton.textContent = 'Hide Cart';
    toggleButton.style.cssText = 'position: fixed; bottom: 20px; left: 20px; padding: 5px 10px; background-color: #4285f4; color: white; border: none; border-radius: 3px; cursor: pointer; z-index: 1000;';
    document.body.appendChild(toggleButton);
    
    toggleButton.addEventListener('click', function() {
        if (dataContainer.style.display === 'none') {
            dataContainer.style.display = 'block';
            toggleButton.textContent = 'Hide Cart';
        } else {
            dataContainer.style.display = 'none';
            toggleButton.textContent = 'Show Cart';
        }
    });
});








{% if uploaded_items_json %}
document.addEventListener('DOMContentLoaded', function() {
    const uploadedItems = {{ uploaded_items_json|safe }};
    // console.log("Uploaded items from server:", uploadedItems);
    processUploadedItems(uploadedItems);
});
{% endif %}


</script>

{% endblock %}
